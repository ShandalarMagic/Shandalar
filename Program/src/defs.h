#ifndef DEFS_H
#define DEFS_H

// Type declarations.  Should contain no function or extern data declarations.

#include <inttypes.h>

/* Creature types are in their own header because there are so many of them. */
#include "subtypes.h"

/* External enumerators for dynamic card ids. It's automatically generated by csv2dat.exe*/
#include "card_id.h"

/* Expansions */
#include "Expansions.h"

#ifndef PACKED
#define PACKED __attribute__((__packed__))
#endif

#ifdef SHANDALAR
#define STATIC_ASSERT(e, msg)	static_assert(e, #msg)
#else
#define STATIC_ASSERT(e, msg)	enum { static_assertion__##msg = 1/(e) }
#endif

#ifdef SHANDALAR
#define PRIVATE_IN_SHANDALAR(arg) private: arg public:
#else
#define PRIVATE_IN_SHANDALAR(arg) arg
#endif

/* Colors */
typedef enum
{
  COLOR_COLORLESS = 0,
  COLOR_BLACK     = 1,
  COLOR_BLUE      = 2,
  COLOR_GREEN     = 3,
  COLOR_RED       = 4,
  COLOR_WHITE     = 5,
  COLOR_ARTIFACT  = 6,
  COLOR_ANY       = 7
#ifdef SHANDALAR
  ,
  COLOR_HYBRID    = 7	// only valid in the context of pay_mana_xbugrwaU[]
#endif
} color_t;

/* Colors */
typedef enum
{
  COLOR_TEST_COLORLESS = 0x01,
  COLOR_TEST_BLACK     = 0x02,
  COLOR_TEST_BLUE      = 0x04,
  COLOR_TEST_GREEN     = 0x08,
  COLOR_TEST_RED       = 0x10,
  COLOR_TEST_WHITE     = 0x20,
  COLOR_TEST_ARTIFACT  = 0x40,
  COLOR_TEST_ANY_COLORED = COLOR_TEST_WHITE | COLOR_TEST_RED | COLOR_TEST_GREEN | COLOR_TEST_BLACK | COLOR_TEST_BLUE,
  COLOR_TEST_ANY       = COLOR_TEST_ANY_COLORED | COLOR_TEST_COLORLESS,
} color_test_t;

/* event_t codes */
typedef enum
{
  EVENT_UNTAP_PHASE			= 0x01,
  EVENT_UPKEEP_PHASE		= 0x04,
  EVENT_DRAW_PHASE			= 0x0A,
  EVENT_MAIN_PHASE1			= 0x14,
  EVENT_DECLARE_ATTACKERS	= 0x15,
  EVENT_DECLARE_BLOCKERS	= 0x1A,
  EVENT_MAX_HAND_SIZE		= 0x1F,
  EVENT_PREVENT_DAMAGE		= 0x21,
  EVENT_CLEANUP				= 0x22,
  EVENT_DAMAGE_PREVENTION	= 0x25,
  EVENT_DAMAGE_REDUCTION	= 0x26,	// Damage (but not necessarily all life loss) has been dealt to a player and is reducing his life; this event can override the life change.  (affected_card_controller/affected_card) is the damage card.  life[] is not yet changed; event_result holds the new value.  Currently this is only sent if the new life total would be lower than 7.
  EVENT_POWER				= 0x32,
  EVENT_TOUGHNESS			= 0x33,
  EVENT_ABILITIES			= 0x34,
  EVENT_RECALC_DAMAGE		= 0x35, // ??
  EVENT_SET_COLOR			= 0x36,
  EVENT_CAN_COUNTER			= 0x38,
  EVENT_POW_BOOST			= 0x39,	// If this card can do something during combat to increase its own power, return the amount it can increase (directly, instead of setting event_result).  Only checked if EA_INF_POWER is set.
  EVENT_TOU_BOOST			= 0x3A,	// If this card can do something during combat to increase its own toughness, return the amount it can increase (directly, instead of setting event_result).  Only checked if EA_INF_TOUGHNESS is set.
  EVENT_CHECK_PUMP			= 0x3B,
  EVENT_CHANGE_TYPE			= 0x3C, // Mok --> CP_RECALC_IDinCT
  EVENT_CAN_SKIP_TURN		= 0x6A, /* Nothing should do anything here except skip-turn effects, and those by setting land_can_be_played |= LCBP_SKIP_TURN.
									 * Purely visual effects like reflagging clonelike cards as needing recalculation are ok as well, since this is the first
									 * event in a turn. */
  EVENT_CAST_SPELL			= 0x6C, // 108
  EVENT_ACTIVATE			= 0x6D,
  EVENT_DEAL_DAMAGE			= 0x6E, // 110
  EVENT_REGENERATE			= 0x70,
  EVENT_RESOLVE_SPELL		= 0x71, // 113
  EVENT_RESOLVE_ACTIVATION	= 0x72,
  EVENT_CAN_ACTIVATE		= 0x73,
  EVENT_CAN_CAST			= 0x74, // 116
  EVENT_GRAVEYARD_FROM_PLAY	= 0x77,
  EVENT_BLOCK_LEGALITY		= 0x78,
  EVENT_ATTACK_LEGALITY		= 0x79,
  EVENT_TRIGGER				= 0x7D,
  EVENT_RESOLVE_TRIGGER		= 0x7E,
  EVENT_COUNT_MANA			= 0x7F,
  EVENT_UNKNOWN80			= 0x80,	// Activated ability being put on the stack (before EVENT_ACTIVATE is dispatched, so of limited utility).  Nothing responds in magic.exe; in shandalar.exe, card_power_artifact() does, incrementing pay_mana[7] (ie *(&_PAY_MANA_ARTIFACT+1)) - also the only thing setting that.  It's used in charge_mana() to decrease the cost.  But then, Microprose didn't enable Power Artifact, so it probably didn't work quite right.
  EVENT_TAP_CARD			= 0x81,	// A card became tapped during tap_card() or EVENT_ACTIVATE.  Dispatched instead of EVENT_PLAY_ABILITY in the latter case.
  EVENT_UNTAP				= 0x82,	// This card is being considered for untapping during the untap phase.
  EVENT_UNTAP_CARD			= 0x83,	// This card has just been untapped.  Sent only to the card itself unless player_bits[controller] & PB_SEND_EVENT_UNTAP_CARD_TO_ALL is set.
  EVENT_SET_UNTAP_COST		= 0x84,
  EVENT_SETUP_UPKEEP_COSTS	= 0x85,
  EVENT_UPKEEP_COSTS_UNPAID	= 0x86,
  EVENT_CHECK_UPK_PAYMENT	= 0x87,
  EVENT_CHECK_UNTAP_PAYMENT	= 0x88,
  EVENT_MUST_ATTACK			= 0x89,
  EVENT_ATTACK_RATING		= 0x8A,
  EVENT_BLOCK_RATING		= 0x8B,
  EVENT_CHECK_ABILITIES		= 0x8C,	// Ridiculously useful, analagous to EVENT_POW_BOOST/EVENT_TOU_BOOST, but for arbitrary cards and also accounts for added abilities.  Increase or decrease check_abilities_power (EXE_DWORD(0x789B50) in Manalink) if something in play can activate (or trigger later) during combat to increase or decrease {affected_card_controller,affected_card}'s power; the same for check_abilities_toughness (EXE_DWORD(0x7A371C)) for toughness; and set bits in check_abilities_keywords (EXE_DWORD(0x78FEF0)) if it can give normal keywords to {affected_card_controller,affected_card} (it can't be used to remove them).  In Manalink, it's only sent when affected_card_controller == HUMAN, but that's easy to change.  Dispatched from setup_ai_combat_abilities() at 0x4AF110.
  EVENT_DISCARD				= 0x8D,
  EVENT_UNKNOWN8E			= 0x8E,
  EVENT_CAN_WASTE_MANA		= 0x8F,
  EVENT_GET_SELECTED_CARD	= 0x90,
  EVENT_PLAY_ABILITY		= 0x91,	// An activated ability was played, but the card did not become tapped during EVENT_ACTIVATE.
  EVENT_BEFORE_COMBAT		= 0x92,
  EVENT_VARIABLE_MANA_SRC	= 0x93,
  EVENT_CARDCONTROLLED		= 0x94,
  EVENT_DISABLE_ABILITIES	= 0xA0,
  EVENT_ENABLE_ABILITIES	= 0xA1,
  EVENT_MODIFY_COST_GLOBAL	= 0xA2,	// In Manalink: Individual card must have EA_PLAY_COST set.  In Shandalar: At least one card on the battlefield must have it set, and this event is only for cost modifications that can reduce a cost to zero.
  EVENT_MODIFY_AB_COST_GL	= 0xA3,
  EVENT_MODIFY_COST			= 0xA4, // In Manalink: Individual card must have new_field&1 ("Modifies Casting Cost") set; it and EVENT_MODIFY_COST_GLOBAL change the cost_xbugrwaU global array, which begins zero-initialized.  In Shandalar, it's always sent, and it and EVENT_MODIFY_COST_GLOBAL change the global_cost (a Mana object) and global_cost_aux (containing hybrid etc. costs) objects, which are preloaded with the card's base mana cost.  global_cost will already have been normalized so there's no negative numbers; set a color to negative if more mana is provided free than needed, so it can be applied towards an X amount.  event_result holds the player paying the cost.
  EVENT_PAY_MODIFIED_COST	= 0xA5, // Mok --> PAY_SELFCOST
  EVENT_MODIFY_MANA_PROD	= 0xA6,
  EVENT_AFTER_DAMAGE		= 0xA7,
  EVENT_GRAVEYARD_ABILITY			= 0xB0,
  EVENT_CAN_ACTIVATE_FROM_HAND		= 0xB1,
  EVENT_ACTIVATE_FROM_HAND			= 0xB2,
  EVENT_RESOLVE_ACTIVATION_FROM_HAND= 0xB3,
  EVENT_GRAVEYARD_ABILITY_UPKEEP	= 0xB4,
  EVENT_PAY_FLASHBACK_COSTS			= 0xB5,
  EVENT_CAN_SPLICE					= 0xB6,
  EVENT_SPLICE						= 0xB7,
  EVENT_CAN_UNMORPH			= 0xB8,
  EVENT_UNMORPH				= 0xB9,
  EVENT_HAUNT				= 0xBA,
  EVENT_TURNED_FACE_UP		= 0xBB,
  EVENT_CAN_PAY_MADNESS_COST= 0xBC,
  EVENT_PAY_MADNESS_COST	= 0xBD,
  EVENT_CHAOS				= 0xBF,
  EVENT_PLANESWALK_IN		= 0xC0,
  EVENT_PLANESWALK_OUT		= 0xC1,
  EVENT_RESOLVE_SPLICE		= 0xC2,
  EVENT_SHOULD_AI_PLAY		= 0xC7,

  /* Cards in the exe only look at the low-order byte, so for example a custom event value of 0x181 would be treated the same as EVENT_TAP_CARD.  No exe-coded
   * card responds directly to an event of value 0, so adding new events that end in 0x00 should be reasonably safe.  Ideally, they should only be sent to
   * functions known to be coded in C; enough cards forward event untouched to exe functions that it's not particularly useful to check. */
  EVENT_SET_LEGACY_EFFECT_NAME	= 0x100,
  EVENT_SET_LEGACY_EFFECT_TEXT	= 0x200,
  EVENT_TRIGGER_RESOLVED		= 0x300,	// Sent at the end of every card's EVENT_RESOLVE_TRIGGER.  Notably, trigger_condition is inaccessible.
  EVENT_BECAME_MONSTROUS		= 0x400,
  //0x500 unused
  EVENT_CAN_MOVE_AURA			= 0x600,
  EVENT_MOVE_AURA				= 0x700,
  EVENT_RESOLVE_MOVING_AURA		= 0x800,
  EVENT_PHASING					= 0x900,
  EVENT_UPKEEP_TRIGGER_ABILITY	= 0xA00,
  EVENT_END_TRIGGER				= 0xB00,	/* Sent as a trigger finishes being dispatched.  Mainly intended to finalize optional triggers; also handy to use
											   for things that should happen exactly once at a time a trigger is sent, but not actually light up in the UI. */
  EVENT_TAPPED_TO_PLAY_ABILITY	= 0xC00,	/* Sent after EVENT_TAP_CARD when a card becomes tapped as a result of EVENT_ACTIVATE, but not when a card becomes
											 * tapped by tap_card().  So each EVENT_ACTIVATE results in either EVENT_PLAY_ABILITY, or EVENT_TAP_CARD followed
											 * by EVENT_TAPPED_TO_PLAY_ABILITY. */
  EVENT_END_OF_UNTAP_STEP			= 0xD00,
  EVENT_PHASE_CHANGED				= 0xE00,	// Beware; may be sent more than once for the same phase.
  EVENT_RESOLVE_THIS_DIES_TRIGGER	= 0xF00,	// Transparently sent by this_dies_trigger().
  EVENT_CHECK_DESTROY_IF_BLOCKED	= 0x1000,	/* Set event_result |= 1 if (affected_card_controller,affected_card) would destroy/exile/etc.
												 * (attacking_card_controller, attacking_card) if one would block the other; |= 2 if affected would be
												 * destoyed/etc.  DIFB_ASK_CARD must be set on (affected_card_controller, affected_card) for it to get this
												 * event, or DIFB_ASK_ALL_CARDS set on any card on the battlefield. */
  EVENT_BEGIN_TURN					= 0x1100,	// Beginning of a non-skipped turn.
  EVENT_CAN_CHANGE_TARGET			= 0x1200,
  EVENT_CHANGE_TARGET				= 0x1300,
  EVENT_STATIC_EFFECTS				= 0x1400,	/* Handle things that should happen "continuously".  Gets sent only to a card's own function.  Removing a card
												 * from play or putting an effect onto the stack will make this get called again, so beware loops. */
  EVENT_MANA_POOL_DRAINING			= 0x1500,	// Sent as a player's mana pool is being set to 0.  Will probably only be sent if a specific player_bits[] or event_flags bit is set.
  EVENT_CHOOSING_TO_UNTAP			= 0x1600,	// Transparently sent by choosing_to_untap().
  EVENT_TRANSFORMED					= 0x1700,
  EVENT_ENTERING_THE_BATTLEFIELD_AS_CLONE	= 0x1800,	// Needed because EVENT_RESOLVE_SPELL (the proper time for "As [something] enters the battlefield" replacement events) only gets sent to the resolving spell.
  EVENT_RESOLVE_ACTIVATED_GRAVEYARD_ABILITY = 0x1900,
  EVENT_RETURN_TO_PLAY_FROM_GRAVE_MODIFIED	= 0x1A00,
//  unused						= 0x1B00,
  EVENT_PLAY_FIRST_HALF						= 0x1C00, // For "split" cards
  EVENT_PLAY_SECOND_HALF					= 0x1D00, // For "split" cards
  EVENT_HAS_MORPH							= 0x1E00, // Needed to discriminate if the card has originally Morph
#ifdef SHANDALAR
  EVENT_SKIP_PHASE							= 0x1F00,	// Set event_result|=1 to skip this phase, or |=2 to skip the rest of the turn without even a cleanup step.  Currently only sent in Shandalar, and only for the upkeep and draw phases.
  EVENT_IS_DISABLING_AURA					= 0x2000,	// Return 1 if this aura prevents the creature it's enchanting from attacking, 2 if it prevents blocking, 3 if it prevents both.  Interpret broadly (e.g., Paralyze does both).
  EVENT_AURA_IS_ENCHANTING_NONPREFERRED		= 0x2100,	// Return 1 if this aura has a preferred target controller and it's enchanting the other player's permanents, e.g. a Pacifism on its owner's own creature.
  EVENT_AURA_IS_CONTROLCHANGER				= 0x2200,	// Return 1 if this card reads similar to "You control enchanted/equipped/otherwise-attached-to object".
  EVENT_AURA_IS_ENCHANT_CREATURE			= 0x2300,	// Return TYPE_CREATURE if this card is an aura with enchant creature, e.g. for Tallowisp or Rootwater Shaman.  (Not "enchant creature you control" or anything like that.)
  EVENT_BEGIN_GAME							= 0x2400,	// Sent to all cards in each player's hand immediately before the first turn of a game.
  EVENT_HAS_ACTIVATION_FOR_T				= 0x2500,	// Return nonzero if this is a permanent with an activated ability with T in its cost.
#endif
  EVENT_EFFECT_CREATED						= 0x2600,	// Shandalar: sent to each effect card immediately after it's created.  Manalink: the same, but only for a handful of specific effects.
#ifdef SHANDALAR
  EVENT_COPY_SPELL							= 0x2700,	// Replaces EVENT_CAST_SPELL when a card is copied by a "Copy spell and choose new targets" effect.  See copy_spell_may_choose_new_targets in events.cpp for details.
#endif
  EVENT_RESOLVE_GENERAL_EFFECT				= 0x2800,	// Sent by some general effect implementations, like legacy_permanents_destroyed_this_way()'s, to their original cards' functions.  player and card will be that of the effect card, so the original source will be get_card_instance(player, card)->damage_source().
#ifdef SHANDALAR
  EVENT_EQUIPMENT_UNATTACHED				= 0x2900,	// Sent to an equipment (that's still in play) when it becomes unattached from something (that's still in play).  Previously-attached object will no longer be in damage_target_player/card, but will still be in damage_source_player/card.  Generally you need a TRIGGER_LEAVES_PLAY handler for when the equipment itself leaves play, too.
  EVENT_PLACED_IN_GRAVEYARD					= 0x2A00,	// Sent to a card after it's been placed in a graveyard.  Player is the card's owner; card is the position in the graveyard.  Only sent to certain cards (currently only Nether Shadow).  This event is likely to be removed in the future.
  EVENT_QUERY_BUSHIDO						= 0x2B00,	// Sent to a card to determine how many points of Bushido it has.  Card function should return the amount directly.
  EVENT_QUERY_MODULAR						= 0x2C00,	// Sent to a card to determine how many points of Modular it has.  Card function should return the amount directly.  (Modular-Sunburst returns 5.)
  EVENT_OVERRIDE_RULES_TEXT					= 0x2D00,	// Return a nonzero pointer to a string (your responsibility to preserve it) to display arbitrary rules text on a card.  Any inspection of the card should be via get_displayed_card_instance().  If an effect card has BYTE0(eot_toughness) = 66, it will also get sent this.
  EVENT_AURA_COULD_ATTACH_IF_PUT_ON_BF		= 0x2E00,	// Works just like EVENT_CAN_CAST, but for an Aura card, should be able to "target" cards with shroud, hexproof, and similar.  Non-Aura cards will return 0 if passed this message, of course.
  EVENT_PREFERRED_COUNTERS					= 0x2F00,	// Query a card for its preferred counter type, which it should return directly.  Returning COUNTER_P1_P1 (== 0) means no preference; avoid +/- counters.  player and card are unset.
  EVENT_BEGIN_TRIGGER						= 0x3000,	// Sent as a trigger begins being dispatched.  Mainly intended to initialize storage.
  EVENT_NONPERMANENT_GRAVEYARD_FROM_PLAY	= 0x3100,	// Identical to EVENT_GRAVEYARD_FROM_PLAY, but sent for non-permanent, non-effect cards.  (Only permanents and effects get EVENT_GRAVEYARD_FROM_PLAY, irritatingly.)
  EVENT_QUERY_VANISHING						= 0x3200,	// Sent to a card to determine whether it has Vanishing.  Card function should return nonzero directly if so.
  EVENT_QUERY_CANT_GAIN_LIFE				= 0x3300,	// Sent, not when attempting to gain life, but to see whether a player could do so as a cost.  Set event_result if so.  affected_card_controller will be the player to gain life.
  EVENT_QUERY_CAN_LOSE_THE_GAME				= 0x3400,	// Sent to see if affected_card_controller can lose the game.  event_result is a bitfield, defined in shandalar.h as LossReason.  Remove the appropriate bits from event_result to prevent loss for a given reason, or set it to 0 to prevent loss entirely.
  EVENT_SPECULATIVE_LIFE					= 0x3500,	// Sent to change affected_card_controller's life value during AI speculation, after adjustment for lifelink and an initial penalty for starting below 0.  affected_card is the player being assessed, which is not necessarily affected_card_controller.  Stored in event_result.  Requires event_flags & EA_LICH.  Intended for Lich-like effects, where the AI is substituting some other value for life.
#endif
  EVENT_SUBTYPE								= 0x3600,	// In Manalink, sent only to one card whose subtype is being queried, with event_result preset to a specific subtype.  Set event_result to 0 to indicate it has the subtype, otherwise leave it alone.
  EVENT_FIGHT								= 0x3700,
  EVENT_QUERY_AWAKEN						= 0x3800,	// Return nonzero to indicate this card has awaken.  player and card will be 0; affected_card_controller and affected_card are undefined.
} event_t;

/* Trigger conditions */
typedef enum
{
  TRIGGER_UPKEEP			= 0xC9, // BEGIN_UPKEEP
  TRIGGER_DURING_UPKEEP		= 0xCA,
  TRIGGER_END_UPKEEP		= 0xCB,
  TRIGGER_END_COMBAT		= 0xCC,
  TRIGGER_EOT				= 0xCD,
  TRIGGER_DRAW_PHASE		= 0xCE,
  TRIGGER_REPLACE_CARD_DRAW	= 0xCF,	// in Shandalar, only set if enable_xtrigger_flags & ENABLE_TRIGGER_REPLACE_CARD_DRAW
  TRIGGER_CARD_DRAWN		= 0xD0,
  TRIGGER_DISCARD			= 0xD1,	// Lets a discard event be replaced, e.g. by Library of Leng.  Shouldn't be used for things that trigger on discards but don't replace them.  Set EXE_BYTE(0x786dd4) to 1 to indicate the discard's been replaced.
  TRIGGER_TAP_CARD			= 0xD2,
  TRIGGER_SPELL_CAST		= 0xD3,
  TRIGGER_LEAVE_PLAY		= 0xD4,
  TRIGGER_GRAVEYARD_FROM_PLAY	= 0xD5,
  TRIGGER_GRAVEYARD_ORDER	= 0xD6,
  TRIGGER_DEAL_DAMAGE		= 0xD7,
  TRIGGER_BOUNCE_PERMANENT	= 0xD8,
  TRIGGER_MUST_ATTACK		= 0xD9,
  TRIGGER_MUST_BLOCK		= 0xDA, // CHOOSE_BLOCKERS ??
  TRIGGER_COMES_INTO_PLAY	= 0xDB,
  TRIGGER_PAY_TO_ATTACK		= 0xDC,
  TRIGGER_PAY_TO_BLOCK		= 0xDD,
  TRIGGER_ATTACKER_CHOSEN	= 0xDE,	// Triggers as each attacker is chosen.  Infuriatingly, it's dispatched after PAY_TO_ATTACK when a human attacks, but before when the AI does.
  TRIGGER_BLOCKER_CHOSEN	= 0xDF,
  TRIGGER_GAIN_LIFE			= 0xE0,
  TRIGGER_END_DAMAGE_PREV	= 0xE1,
  TRIGGER_END_DRAW			= 0xE2,
  TRIGGER_END_MAIN			= 0xE3,
  TRIGGER_END_DISCARD		= 0xE4,
  TRIGGER_XTRIGGER			= 0xE5,
} trigger_t;

/* Unlike events, triggers have to be in the range 200-254, or else they break.  (The exact values are also checked in sub_476F10(), though I'm not sure what
 * use that's put to.  Not being listed there seems harmless so far.)  So in order to add more, what we do is set trigger_condition to the same value for all of
 * them, and set (yet another) global to be the value of our extended trigger.
 *
 * To minimize the chance of confusion, XTRIGGER values don't overlap either events or trigger values.  The high byte should always be exactly 1, and the low
 * byte 0 so it's not misdetected by the exe.
 *
 * Always check for extended triggers with xtrigger_condition() instead of looking at the global directly.  It's semantically equivalent to trigger_condition.
 * It can be used with normal trigger values as well (e.g. xtrigger_condition() == TRIGGER_LEAVE_PLAY).  Among other reasons for not checking directly, the
 * global isn't always cleared when trigger_condition is (particularly by the exe).  Hopefully, attempts to compare trigger_condition against an xtrigger_t will
 * result in a warning.
 *
 * Always dispatch extended triggers with dispatch_xtrigger2().  Its externally-visible behavior is identical to dispatch_trigger2().
 *
 * The way TRIGGER_GRAVEYARD_ORDER and TRIGGER_GRAVEYARD_FROM_PLAY (when called from regenerate_or_graveyard_triggers()), calling a custom function instead of
 * the card's function for EVENT_TRIGGER/EVENT_RESOLVE_TRIGGER/etc., isn't understood at all yet, but it's very unlikely these will be able to work with it.
 * We'll probably have to use triggers in the normal range instead.
 *
 * The X, by the way, is short for EXT_, itself short for EXTENDED_. */
typedef enum
{
  XTRIGGER_ATTACKING	= 0x01000100,	// Triggers once after all attackers are declared, paid for, and tapped.  In manalink, trigger_cause_controller and trigger_cause are always 0; in shandalar, trigger_cause_controller is current_turn; LOWORD(trigger_cause) is the number of attackers declared; and HIWORD(trigger_cause) is (one of) the attacking creatures.
  XTRIGGER_REPLACE_MILL	= 0x01000200,	// Triggers before each card is milled.  trigger_cause_controller is the player being milled; trigger_cause is the position of the card in trigger_cause_controller's deck.  (That's not necessarily 0, for instance if it was milled by Cellar Door.)  It will still be at deck_ptr[trigger_cause_controller][trigger_cause].  Set replace_milled=1 to indicate replacement (with the card revealed or moved to a public zone) or =2 to indicate replacement (with a move to a hidden zone without revealing the card); always check it before doing anything to be sure nothing's already replaced it first.
  XTRIGGER_MILLED		= 0x01000300,	// Triggers after each card is milled.  trigger_cause_controller is the player being milled.  num_milled will contain the number of cards that were milled; they're accessible through cards_milled[].
  XTRIGGER_REPLACE_CARD_TO_GY_FROM_ANYWHERE_BUT_LIBRARY = 0x01000400,	// Triggers before each card is put into a graveyard from anything except mill()/special_mill().  trigger_cause_controller is the player whose graveyard it is; trigger_cause is the iid of the card going to graveyard.  The card currently won't be anywhere.  Set replace_milled=1 (sic) to indicate replacement; always check it before doing anything to be sure nothing's already replaced it first.  This trigger is very blunt, and probably doesn't interact well with "When [something] is put into a graveyard from the battlefield"/"When [something] dies" triggers (it certainly won't interleave with them properly); probably best to also replace during EVENT_GRAVEYARD_FROM_PLAY if there's no choice involved.
  XTRIGGER_CARD_TO_GY_FROM_ANYWHERE_BUT_LIBRARY = 0x01000500,	// Triggers after each card is put into a graveyard from anything except mill()/special_mill().  trigger_cause_controller is the player being milled; trigger_cause is the iid of the card, gy_from_anywhere_pos is the tentative position of the card in the graveyard, and gy_from_anywhere_source is the canonical graveyard_source[][] value of the card so it can be reliably found if it's still there.
  XTRIGGER_SCRY			= 0x01000600,	// Triggers whenever a player scries.  trigger_cause_controller is the player scrying; trigger_cause is the number of cards scryed.
#ifdef SHANDALAR
  XTRIGGER_DISCARDED	= 0x01000700,	// Shandalar only: triggers when a card has been discarded (as opposed to TRIGGER_DISCARD, which is for replacement effects).  trigger_cause_controller is the player who discarded; trigger cause is the graveyard_source of the discarded card; discarded_iid is the original_iid of the discarded card.
  XTRIGGER_LAND_PLAYED	= 0x01000800,	// Shandalar only: a land is being played.  Dispatched instead of TRIGGER_SPELL_CAST.
  XTRIGGER_REPLACE_GAIN_LIFE= 0x01000900,	// Shandalar only: a player is going to gain life; allow that to be replaced.  The amount is stored and can be edited in life_gained.  trigger_cause_controller and trigger_cause are the player gaining life and -1 respectrively.
  XTRIGGER_CARD_SPECIFIC= 0x01000A00,	// Shandalar only: generic trigger dispatched from a specific card to other cards, typically to impose an upkeep payment.  Should be handled by the dispatching card.  trigger_cause_controller and trigger_cause should be the dispatching card.  See shandalar/cards/upkeep:impose_upkeep_cost() for an example.
  XTRIGGER_REPLACE_KILL	= 0x01000B00,	// Shandalar only: sent when a non-effect card or token would go to graveyard or be exiled from the battlefield or stack, including a non-permanent card that was cast.  Happens before EVENT_GRAVEYARD_FROM_PLAY.  Sent only if ENABLE_XTRIGGER_REPLACE_KILL is set; trigger_cause_controller and trigger_cause are the dispatching card, and its kill_code will be accurate.  Set suppress_this_trigger=1 to abort the original kill_card - and you want to do that in essentially all cases of replacement.  Even in the special case of changing a go-to-graveyard to exile, kill the card again rather than setting kill_code.  You'll also need to remove STATUS_DYING in almost all cases.
  XTRIGGER_CARD_DRAWN	= 0x1000C00,	// Shandalar only: A card was drawn (and not replaced).  It's in {trigger_cause_controller, trigger_cause}.
  XTRIGGER_THIS_DIES	= 0x1000D00,	// Shandalar only: This isn't actually ever dispatched.  A card calling HAS_WHEN_THIS_DIES() will have TRIGGER_GRAVEYARD_FROM_PLAY translated into this and then forwarded to it after it's left the battlefield.
  XTRIGGER_LOSE_LIFE	= 0x1000E00,	// Shandalar only: Works exactly like TRIGGER_GAIN_LIFE - either a card must have EA_LICH, or it must be manually set in event_flags; and the amount of life lost is stored in life_gained (always a negative number here)
#endif
  XTRIGGER_1_1_COUNTERS		= 0x1000F00,	// One or more +1/+1 counters were placed on trigger_cause_controller/trigger_cause.  The number of counters is stored in counters_added. Dispatched only if ENABLE_XTRIGGER_1_1_COUNTERS is set.
  XTRIGGER_BECAME_RENOWNED	= 0x1001000,	// {trigger_cause_controller,trigger_cause} just became renowned.
} xtrigger_t;

/* Triggers, unlike events, are relatively computationally expensive.  Triggers that are rarely handled, particularly ones from things that would get dispatched
 * frequently or that would get dispatched several times in a row, shouldn't even be dispatched unless there's a card that can handle it in play.  Analagously
 * to the exe's event_flags, these need to be set in enable_xtrigger_flags by at least one card or the corresponding trigger won't be sent.  The canonical place
 * to do so is after EVENT_CHANGE_TYPE has been fully computed, but there's no event guaranteed to be sent then (doing it during EVENT_CHANGE_TYPE itself is too
 * early, since another card might still change event_result); setting the flag is fast enough that it can be done continuously in card functions. */
typedef enum
{
  ENABLE_XTRIGGER_REPLACE_MILL	= (1<<0),
  ENABLE_XTRIGGER_MILLED		= (1<<1),
  ENABLE_XTRIGGER_REPLACE_CARD_TO_GY_FROM_ANYWHERE_BUT_LIBRARY	= (1<<2),
  ENABLE_XTRIGGER_CARD_TO_GY_FROM_ANYWHERE_BUT_LIBRARY	= (1<<3),
#ifdef SHANDALAR
  ENABLE_XTRIGGER_REPLACE_KILL	= (1<<4),
  ENABLE_TRIGGER_REPLACE_CARD_DRAW	= (1<<5),	// sic
  ENABLE_XTRIGGER_CARD_DRAWN	= (1<<6),
  ENABLE_TRIGGER_BOUNCE_PERMANENT   = (1<<7),	// sic
#endif
  ENABLE_XTRIGGER_1_1_COUNTERS   = (1<<8),
} enable_xtrigger_flags_t;

typedef struct
{
  int internal_card_id;	// internal_card_id of the milled card
  int position;			// position of the milled card in graveyard; not necessarily still accurate
  int source;			// graveyard_source[] value of the milled card; always accurate
} milled_t;

#define IS_AI(p_) (ai_is_speculating == 1 || ((p_) == AI && !(trace_mode & 2)))

/* Resolve trigger options */
typedef enum
{
  // this_dies_trigger assumes this can fit into one byte
  RESOLVE_TRIGGER_OPTIONAL	= 1,
  RESOLVE_TRIGGER_MANDATORY	= 2,
  RESOLVE_TRIGGER_DUH		= 3,	/* Not recognized by the exe, which I hope is obvious.  Handled by a (very few) integrated trigger interfaces to mean
									 * "change to RESOLVE_TRIGGER_MANDATORY if duh_mode is on, otherwise RESOLVE_TRIGGER_OPTIONAL." */

// Nominally optional, but forced if you have duh mode on.  And now badly misnamed.
#define RESOLVE_TRIGGER_AI(p_)	(duh_mode(p_) ? RESOLVE_TRIGGER_MANDATORY : RESOLVE_TRIGGER_OPTIONAL)
#define RESOLVE_TRIGGER_CHECK_LIFE_TOTAL(p_, v_)	((duh_mode(p_) && life[p_]-v_ > 5)? RESOLVE_TRIGGER_MANDATORY : RESOLVE_TRIGGER_OPTIONAL)
#define RESOLVE_TRIGGER_CHECK_DECK_COUNT(p_, v_)	((duh_mode(p_) && count_deck(p_)-v_ > 10)? RESOLVE_TRIGGER_MANDATORY : RESOLVE_TRIGGER_OPTIONAL)

} resolve_trigger_t;

/* Modes for kill_card() */
typedef enum
{
  KILL_BURY      = 1,
  KILL_DESTROY   = 2,
  KILL_SACRIFICE = 3,
  KILL_REMOVE    = 4,
  // Some things use 5 for "bounce permanent" in places that normally hold a kill_t.  actions_t is one, but not the only one.
  KILL_STATE_BASED_ACTION = 17,	/* For things "put into the graveyard" as a result of state-based actions, rule 704; for example, a creature with 0 or less
								 * toughness, a planeswalker with 0 loyalty, planeswalker uniqueness/legend/enchant-world rules, Auras enchanting nothing or
								 * illegal targets.  kill_card() immediately translates this to KILL_SACRIFICE for kill_card_exe, so it'll show up as
								 * KILL_SACRIFICE in kill_code still; but it also sets SF_KILL_STATE_BASED_ACTION so things like It That Betrays don't trigger
								 * for it. */
} kill_t;

/* Modes for new_global_tutor(), reveal_top_cards_of_library_and_choose() */
typedef enum
{
  TUTOR_HAND    = 0,
  TUTOR_DECK    = 1,
  TUTOR_GRAVE   = 2,
  TUTOR_PLAY    = 3,	// Not valid for destination_rest parameter of reveal_top_cards_of_library_and_choose()
  TUTOR_PLAY_TAPPED		= 4,	// Not valid for destination_rest parameter of reveal_top_cards_of_library_and_choose()
  TUTOR_RFG				= 5,
  TUTOR_GET_ID			= 6,	// Not valid for destination_rest parameter of reveal_top_cards_of_library_and_choose()
  TUTOR_PLAY_ATTACKING  = 7,	// Not valid for destination_rest parameter of reveal_top_cards_of_library_and_choose()
  TUTOR_GET_POSITION    = 8,	// Not valid for destination_rest parameter of reveal_top_cards_of_library_and_choose()
  TUTOR_BOTTOM_OF_DECK  = 9,
  TUTOR_TPLAYER_HAND	= 10,
  TUTOR_BOTTOM_OF_DECK_RANDOM  = 11,	// Only valid for the destination_rest parameter of reveal_top_cards_of_library_and_choose()
} tutor_t;

typedef enum
{
  TUTOR_FROM_DECK	= 1,
  TUTOR_FROM_GRAVE	= 2,
  TUTOR_FROM_RFG	= 3,
  TUTOR_FROM_HAND	= 4,
  TUTOR_FROM_GRAVE_NOTARGET	= 5,	// just like TUTOR_FROM_GRAVE, but not affected by graveyard_has_shroud
} tutor_from_t;

/* Card States */
typedef enum
{
  STATE_JUST_DRAWED				= 0x1,
  STATE_IN_PLAY					= 0x2,	// If STATE_INVISIBLE also set, then on the stack and no longer interruptible.
  STATE_ATTACKING				= 0x4,
  STATE_BLOCKING				= 0x8,
  STATE_TAPPED					= 0x10,
  STATE_INVISIBLE				= 0x20, // Mok --> CAST_UNRESOLVED	On the stack.  If STATE_IN_PLAY also set, then no longer interruptible.
  STATE_ATTACKED				= 0x40, // Previously STATE_ATTACKING this turn, but no longer attacking
  STATE_JUST_CAST				= 0x80,
  STATE_PROCESSING				= 0x100,
  STATE_ISBLOCKED				= 0x200, // ??
  STATE_PLAYED_FROM_HAND		= 0x400, // Not what it says.
  STATE_UNKNOWN800				= 0x800,
  STATE_OWNED_BY_OPPONENT		= 0x1000,
  STATE_VIGILANCE				= 0x2000,	// Must be set continuously during EVENT_ABILITIES.
  STATE_BLOCKED					= 0x4000, // Previously STATE_BLOCKING this turn, but no longer blocking
  STATE_UNKNOWN8000				= 0x8000, // MUST_ATTACK ??
  STATE_SICKNESS				= 0x10000,	// Is not the same of the following, why ? - Doesn't exist in Manalink.  In Shandalar, this means "summon sick."
  STATE_SUMMON_SICK				= 0x20000,	// In Shandalar, only STATE_SICKNESS is added to the AI's permanents during speculation; for the human's permanents, and not during speculation, both are.
  STATE_NO_AUTO_TAPPING			= 0x40000,
  STATE_UNKNOWN80000			= 0x80000,
  STATE_CANNOT_TARGET			= 0x100000,
  STATE_TARGETTED				= 0x200000,
  STATE_POWER_STRUGGLE			= 0x400000,	// Seems to be set on control effects to indicate who should gain control when the effect goes away if damage_source_player/card is unset
  STATE_OUBLIETTED				= 0x800000, // Phased ??
  STATE_NONCREATURE_CAN_ATTACK	= 0x1000000,
  STATE_NONCREATURE_CAN_BLOCK	= 0x2000000,

  STATE_IS_TRIGGERING			= 0x10000000,
  STATE_DONT_RECOPY_ONTO_STACK	= 0x20000000,	// If set during EVENT_ACTIVATE, then don't copy the card back into its (already-existing) activation card on the stack.  Caller's responsibility to either update all relevant values there (per recopy_card_onto_stack), or simply not handle EVENT_RESOLVE_ACTIVATION.  Bit is removed when recopying is skipped.  Works only for activation, not casting.
} state_t;

// "status" for "token_status" in "card_instance"
typedef enum
{
  STATUS_HACKED				= 0x2,
  STATUS_SLEIGHTED			= 0x4,
  STATUS_OBLITERATED		= 0x8,
  STATUS_TOKEN				= 0x10,
  STATUS_PERMANENT			= 0x20,
  STATUS_ANIMATED			= 0x40,
  STATUS_DYING				= 0x80,
  STATUS_TIMEWALK			= 0x100,
  STATUS_WALL_CAN_ATTACK	= 0x800,	// Must be set continuously during EVENT_ABILITIES.
  STATUS_LEGACY_TYPECHANGE	= 0x1000,	// Unused by exe.  In Manalink, set during EVENT_CHANGE_TYPE when a card animates itself.
  STATUS_COLOR_FORCED		= 0x2000,
  STATUS_BERSERK			= 0x4000,
  STATUS_CANT_ATTACK		= 0x8000,	// Must be set continuously during EVENT_ABILITIES.
  STATUS_INVISIBLE_FX		= 0x10000,
  STATUS_RED_BORDER			= 0x20000,	// Draws a red border around the edge of smallcard, e.g. when assigning combat damage
  STATUS_COMBAT_DAMAGE		= 0x40000,
  STATUS_TRAMPLE_DAMAGE		= 0x80000,
  STATUS_FIRST_STRIKE_DAMAGE= 0x100000,
  STATUS_ISLAND_SANCTUARY	= 0x400000,
  STATUS_CANNOT_REGENERATE	= 0x800000,
  STATUS_CONTROLLED			= 0x1000000,
  STATUS_BASICLAND_DEPENDANT= 0x2000000,	// Alters displayed an effect card's main text for sleight and hack based on its source's current sleight/hack status, not its status when the effect card was created.  Set only with fx_asterisk in exe.
  STATUS_CANNOT_BE_DESTROYED= 0x4000000, // Indestructible ???
  STATUS_SPECIAL_BLOCKER	= 0x8000000,
  STATUS_CANNOT_LEAVE_PLAY	= 0x40000000
} status_t;

/* Card Types  */
typedef enum
{
  TYPE_NONE			= 0,
  TYPE_LAND			= 1 << 0,
  TYPE_CREATURE		= 1 << 1,
  TYPE_ENCHANTMENT	= 1 << 2,
  TYPE_SORCERY		= 1 << 3,
  TYPE_INSTANT		= 1 << 4,
  TYPE_INTERRUPT	= 1 << 5,
  TYPE_ARTIFACT		= 1 << 6,
  TYPE_EFFECT		= 1 << 7, // All legacy / effect cards
  TYPE_SPELL		= TYPE_SORCERY | TYPE_INSTANT | TYPE_INTERRUPT,
#ifndef SHANDALAR
  TYPE_PERMANENT	= TYPE_LAND | TYPE_CREATURE | TYPE_ENCHANTMENT | TYPE_ARTIFACT,
  TYPE_NONEFFECT	= TYPE_PERMANENT | TYPE_SPELL,
  TYPE_ANY			= TYPE_NONEFFECT | TYPE_EFFECT,
#endif
  // Valid only in targetting
  TARGET_TYPE_TOKEN					= 1 << 12,
  TARGET_TYPE_DAMAGE_LEGACY			= 1 << 13,	// Checked for but unused by exe
  TARGET_TYPE_HACK_SLEIGHT_LEGACY	= 1 << 14,	// Checked for but unused by exe
  TARGET_TYPE_DRAW_CARD_LEGACY		= 1 << 15,	// Checked for but unused by exe
  TARGET_TYPE_PLANESWALKER			= 1 << 16,	// Works for targetting, is_what(), and the make_test() family, but not much else.  All will also accept planeswalkers if all of land/creature/enchantment/artifact are set.
  TARGET_TYPE_NONCREATURE_CAN_BLOCK	= 1 << 25,
#ifdef SHANDALAR
  TYPE_PERMANENT	= TYPE_LAND | TYPE_CREATURE | TYPE_ENCHANTMENT | TYPE_ARTIFACT | TARGET_TYPE_PLANESWALKER,
  TYPE_NONEFFECT	= TYPE_PERMANENT | TYPE_SPELL,
  TYPE_ANY			= TYPE_NONEFFECT | TYPE_EFFECT,
#endif
} type_t;

/* Flags for boost_subtype(), boost_creature_type(), and boost_creature_by_color() */
typedef enum
{
  BCT_CONTROLLER_ONLY	= (1 << 0),
  BCT_INCLUDE_SELF		= (1 << 1),
  BCT_OPPONENT_ONLY		= (1 << 2),
  BCT_NO_SLEIGHT		= (1 << 3),	// don't sleight color choice in boost_creature_by_color()
} bct_t;

/* Static Abilities */
typedef enum
{
  KEYWORD_SWAMPWALK       = 1 <<  0,
  KEYWORD_ISLANDWALK      = 1 <<  1,
  KEYWORD_FORESTWALK      = 1 <<  2,
  KEYWORD_MOUNTAINWALK    = 1 <<  3,
  KEYWORD_PLAINSWALK      = 1 <<  4,
  KEYWORD_FLYING          = 1 <<  5,
  KEYWORD_BANDING         = 1 <<  6,
  KEYWORD_TRAMPLE         = 1 <<  7,
  KEYWORD_FIRST_STRIKE    = 1 <<  8,
  KEYWORD_REGENERATION    = 1 <<  9,
  KEYWORD_REACH           = 1 << 10,
  KEYWORD_PROT_BLACK      = 1 << 11,
  KEYWORD_PROT_BLUE       = 1 << 12,
  KEYWORD_PROT_GREEN      = 1 << 13,
  KEYWORD_PROT_RED        = 1 << 14,
  KEYWORD_PROT_WHITE      = 1 << 15,
  KEYWORD_PROT_ARTIFACTS  = 1 << 16,
  KEYWORD_SHROUD          = 1 << 17, /* Supposed to be prot. enchantments, someone has redefined it... */
  KEYWORD_PROT_INSTANTS   = 1 << 18,
  KEYWORD_PROT_INTERRUPTS = 1 << 19, // Actually, used for the "Changeling" ability
  KEYWORD_PROT_SORCERIES  = 1 << 20,
  KEYWORD_PROT_CREATURES  = 1 << 21, /* SkyMagic editor claims this is banding when attacking. Another double use? */
  KEYWORD_PROT_LANDS      = 1 << 22,
  KEYWORD_DEFENDER        = 1 << 23,
  KEYWORD_RECALC_CHANGE_TYPE=1<< 24,//0x1000000
  KEYWORD_RECALC_TOUGHNESS= 1 << 25,//0x2000000
  KEYWORD_RECALC_POWER    = 1 << 26,//0x4000000
  KEYWORD_RECALC_ABILITIES= 1 << 27,//0x8000000
  KEYWORD_RECALC_SET_COLOR= 1 << 28,//0x10000000
  KEYWORD_INFECT          = 1 << 29,// 0x20000000,	// Previously something else; I suspect fear.  Still checked in one place in the exe.
  KEYWORD_DOUBLE_STRIKE   = 1 << 30,//0x40000100,
/*
  1<<31 is apparently Murk Dwellers' pump-when-not-blocked ability.
*/
  KEYWORD_BASIC_LANDWALK  = KEYWORD_SWAMPWALK|KEYWORD_ISLANDWALK|KEYWORD_FORESTWALK|KEYWORD_MOUNTAINWALK|KEYWORD_PLAINSWALK,
  KEYWORD_PROT_COLORED    = KEYWORD_PROT_BLACK|KEYWORD_PROT_BLUE|KEYWORD_PROT_GREEN|KEYWORD_PROT_RED|KEYWORD_PROT_WHITE,
  KEYWORD_PRISTINE        = KEYWORD_PROT_COLORED|KEYWORD_PROT_ARTIFACTS,
  KEYWORD_RECALC_ALL      = KEYWORD_RECALC_CHANGE_TYPE|KEYWORD_RECALC_TOUGHNESS|KEYWORD_RECALC_POWER|KEYWORD_RECALC_ABILITIES|KEYWORD_RECALC_SET_COLOR,
  KEYWORD_NONABILITIES    = KEYWORD_RECALC_ALL|(1<<31),
} keyword_t;

// Special abilities
typedef enum
{
  SP_KEYWORD_FEAR            = 1<<0,
  SP_KEYWORD_LIFELINK        = 1<<1,
  SP_KEYWORD_HASTE           = 1<<2,
  SP_KEYWORD_VIGILANCE       = 1<<3,
  SP_KEYWORD_UNBLOCKABLE     = 1<<4,
  SP_KEYWORD_CANNOT_BLOCK    = 1<<5,
  //SP_KEYWORD_INFECT          = 1<<6,	// unused
  //SP_KEYWORD_CANNOT_ATTACK   = 1<<7,	// unused
  SP_KEYWORD_SHADOW          = 1<<8,
  SP_KEYWORD_DEATHTOUCH      = 1<<9,
  SP_KEYWORD_MUST_ATTACK	 = 1<<10,	// must be called continuously
  SP_KEYWORD_INDESTRUCTIBLE	 = 1<<11,	// can't be added by bit; must be called continuously
  SP_KEYWORD_MUST_BE_BLOCKED = 1<<12,	// must be called continuously
  SP_KEYWORD_FLANKING		 = 1<<13,	// must be called continuously
  SP_KEYWORD_WITHER			 = 1<<14,
  SP_KEYWORD_BUSHIDO		 = 1<<15,	// can't be added by bit; must be called continuously
  //SP_KEYWORD_WILL_DEAL_DOUBLE_DAMAGE	= 1<<16,	// unused
  //SP_KEYWORD_WILL_RECEIVE_DOUBLE_DAMAGE	= 1<<17,	// unused
  SP_KEYWORD_CANNON_FODDER				= 1<<18,	// doesn't belong here; can't be added by bit
  //SP_KEYWORD_DEFENDER					= 1<<19,	// unused
  SP_KEYWORD_RFG_WHEN_DAMAGE			= 1<<20,	// can't be added by bit
  //SP_KEYWORD_NEGATE_ABILITY				= 1<<21,	// unused
  SP_KEYWORD_LURE						= 1<<22,	// must be called continuously
  SP_KEYWORD_HEXPROOF					= 1<<23,
  SP_KEYWORD_FREEZE_WHEN_DAMAGE			= 1<<24,	// can't be added by bit; must be called continuously
  SP_KEYWORD_INTIMIDATE					= 1<<25,
  SP_KEYWORD_MUST_BLOCK					= 1<<26,	// must be called continuously
  SP_KEYWORD_SHADOW_HOSER				= 1<<27,
  SP_KEYWORD_DIE_AT_EOT					= 1<<28,	// doesn't belong here
//  SP_KEYWORD_PERSIST					= 1<<29,	// unused
  SP_KEYWORD_HORSEMANSHIP				= 1<<30,
  SP_KEYWORD_DOES_NOT_END_AT_EOT		= 1<<31,
} sp_keyword_t;

/* Phases of turn */
typedef enum
{
  PHASE_START				=  0x0,
  PHASE_UNTAP				=  0x1,
  PHASE_BEGIN_UPKEEP		=  0x2,
  PHASE_UNKOWN3				=  0x3,
  PHASE_UPKEEP				=  0x4,
  PHASE_UNKOWN5				=  0x5,
  PHASE_DRAW				=  0xA,
  PHASE_MAIN1				= 0x14,
  PHASE_DECLARE_ATTACKERS	= 0x15,
  PHASE_BEFORE_BLOCKING		= 0x16,
  PHASE_DECLARE_BLOCKERS	= 0x17,
  PHASE_AFTER_BLOCKING		= 0x18,
  PHASE_FIRST_STRIKE_DAMAGE	= 0x19,
  PHASE_NORMAL_COMBAT_DAMAGE= 0x1A,
  PHASE_NORMAL_COMBAT_DAMAG2= 0x1B,
  PHASE_MAIN2				= 0x1E,
  PHASE_DISCARD				= 0x1F,
  PHASE_CLEANUP2			= 0x20,
  PHASE_UNKNOWN21			= 0x21,
  PHASE_CLEANUP				= 0x22,
  PHASE_DAMAGE_PREVENTION	= 0x25,
} phase_t;

typedef struct target_struct
{
  int32_t player;
  int32_t card;
} target_t;

typedef enum {
	// Only one byte wide, and they must be properly additive, since other effects may set additional bits.

	// Send an EVENT_CHECK_DESTROY_IF_BLOCKED to find out.  Set event_result=1 within handler to indicate destruction.
	DIFB_ASK_CARD		= 0x1,	/* sends EVENT_CHECK_DESTROY_IF_BLOCKED only to the card being checked, with (affected_card_controller,affected_card) the card
								 * being checked and attacking_player/attacking_card the other card (whether it's actually the attacker or blocker) */
	DIFB_ASK_ALL_CARDS	= 0x2,	/* sends EVENT_CHECK_DESTROY_IF_BLOCKED to all cards, setting affected_card_controller, affected_card, attacking_player, and
								 * attacking_card as above.  Overrides DIFB_ASK_CARD.  Avoid if possible. */

	// Static checks.
	DIFB_DESTROYS_NONWALLS		= 0x4,	/* Destroys any non-Wall creatures that block or are blocked by this card.  (To get just one or the other, set
										 * destroys_if_blocked only during the appropriate turn.) */
	DIFB_DESTROYS_WALLS			= 0x8,	// Destroys any Wall creatures that block or are blocked by this card.
	DIFB_DESTROYS_ALL			= (DIFB_DESTROYS_NONWALLS|DIFB_DESTROYS_WALLS),	// Destroys all creatures that block or are blocked by this card.
	DIFB_DESTROYS_UNPROTECTED	= 0x10,	/* Destroys all creatures that can be damaged by this.  Mostly suitable for deathtouch, though it makes the AI think
										 * that blocking/being blocked causes destruction, not that the deathtouch creature must damage to destroy. */
} destroys_if_blocked_t;

// Counter indices.
#ifdef SHANDALAR
enum counter_t: uint8_t
#else
typedef enum
#endif
{
	COUNTER_P1_P1		= 0,
	COUNTER_M1_M1		= 1,
	COUNTER_P0_P1		= 2,
	COUNTER_P0_P2		= 3,
	COUNTER_P1_P0		= 4,
	COUNTER_P1_P2		= 5,
	COUNTER_P2_P0		= 6,
	COUNTER_P2_P2		= 7,
	COUNTER_M0_M1		= 8,
	COUNTER_M0_M2		= 9,
	COUNTER_M1_M0		= 10,
	COUNTER_M2_M1		= 11,

	COUNTER_M2_M2		= 12,
	COUNTER_AGE			= 13,
	COUNTER_AIM			= 14,
	COUNTER_ARROW		= 15,
	COUNTER_ARROWHEAD	= 16,
	COUNTER_AWAKENING	= 17,
	COUNTER_BLAZE		= 18,
	COUNTER_BLOOD		= 19,
	COUNTER_BOUNTY		= 20,
	COUNTER_BRIBERY		= 21,
	COUNTER_CARRION		= 22,
	COUNTER_CHIP		= 23,

	COUNTER_CORPSE		= 24,
	COUNTER_CREDIT		= 25,
	COUNTER_CUBE		= 26,
	COUNTER_CURRENCY	= 27,
	COUNTER_DEATH		= 28,
	COUNTER_DELAY		= 29,
	COUNTER_DEPLETION	= 30,
	COUNTER_DESPAIR		= 31,
	COUNTER_DEVOTION	= 32,
	COUNTER_DIVINITY	= 33,
	COUNTER_DOOM		= 34,
	COUNTER_DREAM		= 35,

	COUNTER_ECHO		= 36,
	COUNTER_ELIXIR		= 37,
	COUNTER_ENERGY		= 38,
	COUNTER_EON			= 39,
	COUNTER_EYEBALL		= 40,
	COUNTER_FADE		= 41,
	COUNTER_FATE		= 42,
	COUNTER_FEATHER		= 43,
	COUNTER_FILIBUSTER	= 44,
	COUNTER_FLAME		= 45,
	COUNTER_FLOOD		= 46,
	COUNTER_FUNGUS		= 47,

	COUNTER_FUNK		= 48,
	COUNTER_FUSE		= 49,
	COUNTER_GLYPH		= 50,
	COUNTER_GOLD		= 51,
	COUNTER_GROWTH		= 52,
	COUNTER_HATCHLING	= 53,
	COUNTER_HEALING		= 54,
	COUNTER_HOOFPRINT	= 55,
	COUNTER_HOURGLASS	= 56,
	COUNTER_HUNGER		= 57,
	COUNTER_HUSK		= 58,
	COUNTER_ICE			= 59,

	COUNTER_INFECTION	= 60,
	COUNTER_INTERVENTION= 61,
	COUNTER_JAVELIN		= 62,
	COUNTER_KI			= 63,
	COUNTER_LEVEL		= 64,
	COUNTER_LORE		= 65,
	COUNTER_LOYALTY		= 66,
	COUNTER_LUCK		= 67,
	COUNTER_MAGNET		= 68,
	COUNTER_MANIFESTATION	= 69,
	COUNTER_MANNEQUIN	= 70,
	COUNTER_MATRIX		= 71,

	COUNTER_MINE		= 72,
	COUNTER_MINING		= 73,
	COUNTER_MIRE		= 74,
	COUNTER_MUSIC		= 75,
	COUNTER_MUSTER		= 76,
	COUNTER_NET			= 77,
	COUNTER_OMEN		= 78,
	COUNTER_ORE			= 79,
	COUNTER_PAGE		= 80,
	COUNTER_PAIN		= 81,
	COUNTER_PARALYZATION= 82,
	COUNTER_PETAL		= 83,

	COUNTER_PETRIFICATION	= 84,
	COUNTER_PHYLACTERY	= 85,
	COUNTER_PIN			= 86,
	COUNTER_PLAGUE		= 87,
	COUNTER_POLYP		= 88,
	COUNTER_POP			= 89,
	COUNTER_PRESSURE	= 90,
	COUNTER_PUPA		= 91,
	COUNTER_QUEST		= 92,
	COUNTER_RUST		= 93,
	COUNTER_SCREAM		= 94,
	COUNTER_SCROLL		= 95,

	COUNTER_SHELL		= 96,
	COUNTER_SHIELD		= 97,
	COUNTER_SHOE		= 98,
	COUNTER_SHRED		= 99,
	COUNTER_SLEEP		= 100,
	COUNTER_SLEIGHT		= 101,
	COUNTER_SLIME		= 102,
	COUNTER_SOOT		= 103,
	COUNTER_SPORE		= 104,
	COUNTER_STORAGE		= 105,
	COUNTER_STRIFE		= 106,
	COUNTER_STUDY		= 107,

	COUNTER_THEFT		= 108,
	COUNTER_THIRD_DEGREE_BURN	= 109,
	COUNTER_TIDE		= 110,
	COUNTER_TIME		= 111,
	COUNTER_TOWER		= 112,
	COUNTER_TRAINING	= 113,
	COUNTER_TRAP		= 114,
	COUNTER_TREASURE	= 115,
	COUNTER_VELOCITY	= 116,
	COUNTER_VERSE		= 117,
	COUNTER_VITALITY	= 118,
	COUNTER_WAGE		= 119,

	COUNTER_WINCH		= 120,
	COUNTER_WIND		= 121,
	COUNTER_WISH		= 122,
	COUNTER_CHARGE		= 123,
	COUNTER_CRYSTAL		= 124,
	COUNTER_GEM			= 125,
	COUNTER_ISOLATION	= 126,

	// Updates need to be mirrored in Text.res:CUECARD_COUNTERS_SPECIAL; the final entry for COUNTER_end should just be "Counters"

	COUNTER_end,
	COUNTER_invalid		= 255,
#ifndef SHANDALAR
} counter_t;
#else
};
STATIC_ASSERT(sizeof(counter_t) == 1, counter_t_wrong_size);
#endif

#ifdef SHANDALAR
struct card_instance_struct;
struct csvid_t;

struct iid_t
{
	iid_t(void)	{}
	explicit iid_t(int raw_val): raw(raw_val)	{}
	explicit iid_t(uint16_t raw_val): raw(raw_val == 0xFFFF ? -1 : (int)raw_val)	{}
	explicit iid_t(uint32_t raw_val): raw(raw_val)	{}
	explicit iid_t(const card_instance_struct* inst);
	iid_t(int player, int card);
	explicit iid_t(target_struct t);
	explicit iid_t(csvid_t t);

	iid_t& operator++(void)	{ ++raw;	return *this; }

	bool ok(void) const		{ return raw >= 0; }
	csvid_t csvid(void) const;

	int raw;
};

struct csvid_t
{
	csvid_t(void) {}
	/*implicit*/ csvid_t(card_id_t id): raw(id)	{}
	explicit csvid_t(int raw_val): raw(raw_val)	{}
	explicit csvid_t(uint32_t raw_val): raw(raw_val)	{}
	explicit csvid_t(uint16_t raw_val): raw(raw_val == 0xFFFF ? -1 : (int)raw_val)	{}
	explicit csvid_t(const card_instance_struct* inst);
	csvid_t(int player, int card);
	explicit csvid_t(target_struct t);
	explicit csvid_t(iid_t t);

	bool ok(void) const		{ return raw >= 0; }
	iid_t iid(void) const;

	int raw;
};
#endif

#ifdef SHANDALAR
struct card_aux_t;
#endif

/* Info struct */
typedef struct card_instance_struct
{
  /* some values might be padding */
  uint8_t	special_counters;	/*  0x00 */
  uint8_t	counters2;			/*  0x01 */	// Originally -0/-2 counters from Spirit Shackle
  uint8_t	counters3;			/*  0x02 */	// Originally -1/-1 counters from Unstable Mutation
  uint8_t	counters4;			/*  0x03 */	// Originally -0/-1 counters
  int32_t	damage_target_card;	/*  0x04 */	// Card this aura or effect card is attached to.
  uint32_t	state;				/*  0x08 */
  int8_t	damage_source_player;	/*  0x0C */ //  int32_t  damage_source_player;
  int8_t	unused0;			/*  0x0D */	// Shandalar: untouched
  int16_t	toughness;			/*  0x0E */
  uint16_t	damage_on_card;		/*  0x10 */
  int16_t	counter_power;		/*  0x12 */
  uint32_t	unknown0x14;		/*  0x14 */	// activating trigger
  uint32_t	token_status;		/*  0x18 */
  int16_t	counter_toughness;	/*  0x1C */
  PRIVATE_IN_SHANDALAR(int8_t	color;)				/*  0x1E */
  int8_t	destroys_if_blocked;/*  0x1F */	/* Formerly enemy_against_color.  Uses values in destroys_if_blocked_t.  Set to 0 at the start of EVENT_CHANGE_TYPE, and should be reset in response.  AI hinting only. */
  int32_t	dummy3;				/*  0x20 */	// A dynamically-created internal_card_id stored here on a card in play, or in internal_card_id in any card, won't get reaped in end_turn_phase()
  uint8_t	blocking;			/*  0x24 */	// Banding id, if attacking
  PRIVATE_IN_SHANDALAR(int8_t	initial_color;)		/*  0x25 */	// Shandalar: untouched
  int16_t	unused0x26;			/*  0x26 */	// Exe version of rampage() uses this as temporary storage. (!)  That's no longer called, and the data's otherwise entirely untouched.  Shandalar: untouched
  uint32_t	regen_status;		/*  0x28 */	// Keywords.
#ifdef SHANDALAR
  card_aux_t* aux;
  uint32_t	unused30;
#else
  uint8_t	mana_to_untap[8];	/*  0x2C */	// No longer used in Manalink, but still read by the exe in one place and still written in one place.  To reclaim, make check_untap_payment() just return 0, and rewrite setup_upkeep_costs_and_set_untap_cost() to not touch it.
#endif
  int16_t	power;				/*  0x34 */
  uint8_t	number_of_targets;	/*  0x36 */
  uint8_t	unknown0x37;		/*  0x37 */	// Used only on damage cards, apparently for temporary storage
  int32_t	info_slot;			/*  0x38 */
  PRIVATE_IN_SHANDALAR(uint32_t	original_internal_card_id;)	/*  0x3C */ // Mok : CD_CardIDinCT_Parent
  uint8_t	color_id[6];		/*  0x40 */ // cless -> black -> blue -> green -> red -> white - Sleight of Mind data
  PRIVATE_IN_SHANDALAR(uint16_t	backup_internal_card_id;)	/*  0x46 */ // internal_card_id is stored here at the end of EVENT_CHANGE_TYPE.  A crutch to deal with the poor design decision of setting internal_card_id == -1 to indicate a card's left play.
  int32_t	damage_source_card;	/*  0x48 */ /* damage source card */
#ifndef SHANDALAR
  uint32_t	eot_toughness;		/*  0x4C */	// Bytes 0 and 1 manipulate text-modifiers on csvid=903 effect cards; otherwise reserved for individual card use.
#else
  union {
	  uint32_t eot_toughness;
	  struct {
		  uint8_t eot_toughness0;
		  uint8_t eot_toughness1;
		  uint8_t eot_toughness2;
		  uint8_t eot_toughness3;
	  };
  };
#endif
  int8_t	damage_target_player;	/*  0x50 */	// Player of card this aura or effect card is attached to.
#ifdef SHANDALAR
  counter_t special_counter_type;
  counter_t counter2_type;
  counter_t counter3_type;
#else
  uint8_t	special_counter_type;	/*  0x51 */
  uint8_t	unk52;				/*  0x52 */	// Entirely untouched by exe.
  uint8_t	unk53;				/*  0x53 */	// Entirely untouched by exe.
#endif
  uint32_t	timestamp;			/*  0x54 */
  PRIVATE_IN_SHANDALAR(uint8_t	mana_color;)			/*  0x58 */
#ifdef SHANDALAR
  counter_t counter4_type;
  counter_t counter5_type;
  counter_t counter6_type;
#else
  uint8_t	card_color;			/*  0x59 */
  uint8_t	unk5a;				/*  0x5A */
  uint8_t	unk5b;				/*  0x5B */
#endif
  uint32_t	upkeep_flags;		/*  0x5C */	// Eventual candidate for reclamation.  Used in: Curse Artifact, Mishra's War Machine, Brass Man, Colossus of Sardia, Elder Spawn, Cyclone, 0x434040, 0x435b50, 0x436740, 0x437620, 0x437670, Copper Tablet, Mana Crypt, Ghazban Ogre, Serendib Djinn, Juzam Djinn, Yawgmoth Demon, 0x475a30, 0x476b90, 0x477410, Feedback, Power Leak, Energy Flux, Erosion, Cursed Land, Karma, Sunken City, Stasis, Magnetic Mountain, Power Surge, Wanderlust, Unstable Mutation, Warp Artifact, Power Struggle, Conversion, Junun Efreet, Phantasmal Forces, Force of Nature, Cosmic Horror, Lord of the Pit, 0x4d9a30.
  int32_t	attack_rating;		/*  0x60 */
  PRIVATE_IN_SHANDALAR(uint16_t	display_pic_int_id;)	/*  0x64 */
  uint16_t	display_pic_num;	/*  0x66 */
  uint8_t	kill_code;			/*  0x68 */
#ifdef SHANDALAR
  counter_t counter7_type;
  uint8_t	counters6;
  uint8_t	counters7;
#else
  uint8_t	unk69;				/*  0x69 */	// Entirely untouched by exe.
  uint8_t	unk6A;				/*  0x6A */	// Entirely untouched by exe.
  uint8_t	unk6B;				/*  0x6B */	// Entirely untouched by exe.
#endif
  PRIVATE_IN_SHANDALAR(int32_t	internal_card_id;)	/*  0x6C */	// a csvid, not an internal_card_id, despite the misnaming
  uint32_t	unknown0x70;		/*  0x70 */ /* activateability */
  target_t	targets[19];		/*  0x74 */
  int32_t	parent_controller;	/* 0x10C */
  int32_t	parent_card;		/* 0x110 */
  int8_t	hack_mode[6];		/* 0x114 */ // colorless -> black -> blue -> green->red -> white
  uint16_t	unknown0x11a;		/* 0x11A */	// originally -2/-1 counters and +1/+2 counters	Shandalar: untouched
  uint32_t	untap_status;		/* 0x11C */	// Only bits 1 and 2 are used by the exe; but the whole dword is cleared in untap_phase().
  uint8_t	counters;			/* 0x120 */	// originally +1/+1 counters from Dwarven Weaponsmith
  uint8_t	counters5;			/* 0x121 */	// originally +1/+1 counters from Ashnod's Transmogrant
  uint16_t	unknown0x122;		/* 0x122 */	// originally +0/+1 and +2/+2 counters
  uint8_t	upkeep_colorless;	/* 0x124 */	// These seven bytes are strong candidates for reclamation.  Used in: 0x402B60, 0x437670, Energy Flux, Sunken City, Stasis, Conversion, Junun Efreet, Phantasmal Force, Force of Nature, Cosmic Horror
  uint8_t	upkeep_black;		/* 0x125 */
  uint8_t	upkeep_blue;		/* 0x126 */
  uint8_t	upkeep_green;		/* 0x127 */
  uint8_t	upkeep_red;			/* 0x128 */
  uint8_t	upkeep_white;		/* 0x129 */
  uint8_t	upkeep_artmana;		/* 0x12A */
  uint8_t	counters_m1m1;		/* 0x12B */	// Shandalar: untouched
#ifdef SHANDALAR	// strongly-typed accessors
  iid_t original_iid(void) const				{ return iid_t(original_internal_card_id); }
  void set_original_iid(iid_t iid_val)			{ original_internal_card_id = iid_val.raw; }
  csvid_t display_pic_csvid(void) const			{ return csvid_t(display_pic_int_id); }
  void set_display_pic_csvid(csvid_t csvid_val)	{ display_pic_int_id = csvid_val.raw & 0xFFFF; }
  iid_t backup_iid(void) const					{ return iid_t(backup_internal_card_id); }
  void set_backup_iid(iid_t iid_val)			{ backup_internal_card_id = iid_val.raw & 0xFFFF; }
  iid_t cur_iid(void) const						{ return iid_t(internal_card_id); }
  void set_cur_iid(iid_t iid_val)				{ internal_card_id = iid_val.raw; }
  iid_t iid(void) const							{ iid_t id{internal_card_id};	if (!id.ok()) id = iid_t(backup_internal_card_id);	return id; }

  keyword2_t keywords2(void) const;
  void set_keywords2(keyword2_t kw2_val);
  void add_keywords2(keyword2_t kw2_val);
  void remove_keywords2(keyword2_t kw2_val);

  instance_flags_t flags(void) const			{ return (instance_flags_t)(uint8_t)initial_color; }
  void set_flags(instance_flags_t if_val)		{ initial_color = (int8_t)(uint8_t)if_val; }
  void add_flags(instance_flags_t if_val)		{ initial_color |= (int8_t)(uint8_t)if_val; }
  void remove_flags(instance_flags_t if_val)	{ initial_color &= ~(int8_t)(uint8_t)if_val; }

  // Conveniences.  "(inst->damage_target_player, inst->damage_target_card)" is too verbose.
  target_t attached_to(void) const				{ return {damage_target_player, damage_target_card}; }
  bool attached_to(target_t t) const			{ return damage_target_card == t.card && damage_target_player == t.player; }
  bool attached_to(int p, int c) const			{ return damage_target_card == c && damage_target_player == p; }
  card_instance_struct* attached_to_inst(void) const;	// get_card_instance(attached_to())
  bool attached_to(type_t typ) const;			// damage_target_card >= 0 && damage_target_player >= 0 && (type(attached_to()) & typ)
  void attach_to(int p, int c)					{ damage_target_player = p;	damage_target_card = c; }
  void attach_to(target_t t)					{ attach_to(t.player, t.card); }

  target_t damage_source(void) const			{ return {damage_source_player, damage_source_card}; }
  bool damage_source(target_t t) const			{ return damage_source_card == t.card && damage_source_player == t.player; }
  bool damage_source(int p, int c) const		{ return damage_source_card == c && damage_source_player == p; }
  card_instance_struct* damage_source_inst(void) const;	// get_card_instance(damage_source())

  target_t parent(void) const					{ return {parent_controller, parent_card}; }
  bool parent(target_t t) const					{ return parent_card == t.card && parent_controller == t.player; }
  bool parent(int p, int c) const				{ return parent_card == c && parent_controller == p; }
  card_instance_struct* parent_inst(void) const;	// get_card_instance(parent())

  color_test_t colors(void) const				{ return static_cast<color_test_t>(static_cast<uint8_t>(color)); }
  color_test_t set_colors(color_test_t val)		{ return static_cast<color_test_t>(static_cast<uint8_t>(color = val)); }

  color_test_t mana_colors(void) const			{ return static_cast<color_test_t>(mana_color); }
  color_test_t set_mana_colors(color_test_t val){ return static_cast<color_test_t>(mana_color = val); }
#endif
} PACKED card_instance_t;

/* Data struct */
typedef struct
{
  uint8_t	secret;
  char		name[18];       /* 0x01 */
  uint8_t	reserved1[17];
  PRIVATE_IN_SHANDALAR(uint16_t	id;)	/* 0x24 */
  uint16_t	reserved2;
  uint8_t	type;	// ct_all.csv:Type:Effect..Type::Land
  uint8_t	subtype;	// ct_all.csv:Family
  PRIVATE_IN_SHANDALAR(uint8_t	color;)	// ct_all.csv:Color Unused..Color Colorless
/*
  uint8_t  cc[3];
  uint16_t power;
  uint16_t toughness;
  uint16_t reserved3;
*/
  uint8_t	cc[3];	// 0:colored mana, 1:colorless mana, 2:flags
  int16_t	power;
  int16_t	toughness;
  uint8_t	new_field;	//ct_all.csv:Extra Flags (Unused)..Modifies Casting Cost
  uint8_t	reserved3;	//ct_all.csv:Unused (next to Code Address)
  uint32_t	code_pointer;
  uint32_t	static_ability;	//ct_all.csv:Ability:Unknown..Ability:Swampwalk
  uint32_t	extra_ability;	//ct_all.csv:Flags:Play Cost..Flags:Activate
  uint8_t	rarity; // unused in current Manalink
  uint8_t	act_phases;	//ct_all.csv:Activate after Combat..Play before Combat
  uint8_t	expansion; // unused in current Manalink
  uint8_t	creature_rating;	// only -2 through 3 are accepted by ct2exe
  uint8_t	reserved4[4];
#ifdef SHANDALAR
  csvid_t csvid(void) const			{ return csvid_t(id); }
  void set_csvid(csvid_t csvid_val)	{ id = csvid_val.raw & 0xFFFF; }

  color_test_t colors(void) const				{ return static_cast<color_test_t>(color); }
  color_test_t set_colors(color_test_t val)		{ return static_cast<color_test_t>(color = val); }
#endif
} PACKED card_data_t;

typedef enum
{
	UPKEEP_UPKEEP_TRIGGER		= 0x001,
	UPKEEP_UPKEEP_BURY_IF_UNPAID= 0x002,
	UPKEEP_UPKEEP_DONE			= 0x004,
	UPKEEP_UPKEEP_CANTPAY		= 0x008,
	UPKEEP_UNTAP_TRIGGER		= 0x010,
	UPKEEP_UNTAP_PAID			= 0x040,
	UPKEEP_UNTAP_DONE			= 0x080,
	UPKEEP_UPKEEP_NODIALOG		= 0x100,
	UPKEEP_UPKEEP_UNPAID		= 0x200,
} upkeep_flags_t;

typedef enum
{
	ACT_PHASE_PLAY_BEFORE_COMBAT		= 0x1,
	ACT_PHASE_PLAY_BEFORE_BLOCKERS		= 0x2,
	ACT_PHASE_PLAY_AFTER_BLOCKERS		= 0x4,
	ACT_PHASE_PLAY_AFTER_COMBAT			= 0x8,
	ACT_PHASE_PLAY_ALL					= 0xF,
	ACT_PHASE_ACTIVATE_BEFORE_COMBAT	= 0x10,
	ACT_PHASE_ACTIVATE_BEFORE_BLOCKERS	= 0x20,
	ACT_PHASE_ACTIVATE_AFTER_BLOCKERS	= 0x40,
	ACT_PHASE_ACTIVATE_AFTER_COMBAT		= 0x80,
	ACT_PHASE_ACTIVATE_ALL				= 0xF0,
} act_phases_t;

/* Known values for "subtype / family" in card_data */
typedef enum
{
	// default			= -1
	SUB_WALL			= 0, //if a creature has this value set, it could attack only if enchanted by "Animate Wall" or if "Rolling Stones" are in play.
	SUB_MERFOLK			= 1,
	SUB_ZOMBIE			= 2,
	SUB_GOBLIN			= 3,
	SUB_DWARF			= 4,
	SUB_EFREET			= 5,
	SUB_DJINN			= 6,
	SUB_RAT				= 8,	// Also Urza lands
	SUB_ARTIFACT_LAND	= 9,
	SUB_ELEPHANT		= 10,
	SUB_MAMMOTH			= 11,
	SUB_DUAL_LAND		= 12, //(if a land does not have this value, it won't be animated by cards like Living Lands and Kormus Bell)
	SUB_BASIC_LAND		= 13, //(It's used ONLY for the 5 basic lands)
	SUB_LEGENDARY		= 14,
	SUB_LEGENDARY_LAND	= 15,
	SUB_ENCHANT_WORLD	= 16,
} subtype_in_card_data_t;

/* Extra ability is cards_data */
typedef enum
{
	EA_ACT_ABILITY		= 0x1,
	EA_ACT_INTERRUPT	= 0x2,
	EA_PROTECT			= 0x4,
	EA_INF_POWER		= 0x8,
	EA_INF_TOUGHNESS	= 0x10,
	EA_COUNTERS			= 0x20,
	EA_UNK40			= 0x40,		// copper tablet/disrupting scepter
	EA_UNK80			= 0x80,		// Shandalar: more expensive?
	EA_UNK100			= 0x100,	// Shandalar: card may be put in a dungeon; not selectable in cardpicker
	EA_UNK200			= 0x200,	// Shandalar: double cost?
	EA_UNK400			= 0x400,	// Shandalar: rarer?  Lich, most Arabian Nights and Antiquities cards
	EA_UNK800			= 0x800,	// Shandalar: card not selectable in cardpicker.  Unclear if this is its primary function or a side effect.
	EA_MANA_SOURCE		= 0x1000,
	EA_INTERRUPT		= 0x2000,
	EA_UNK4000			= 0x4000,	// Interrupt effects
	EA_BECAME_CREATURE	= 0x8000,
	EA_PAID_MANASOURCE	= 0x10000,
	EA_ACT_USE_X		= 0x20000,

	// The following bits, up to and including EA_CONTROLLED, are set in event_flags at the end of get_abilities(...EVENT_CHANGE_TYPE).
	EA_MARTYR			= 0x40000,	// Veteran Bodyguard-like effects
	EA_SELECT_ATTACK	= 0x80000,
	EA_SELECT_BLOCK		= 0x100000,
	EA_LICH				= 0x200000,
	EA_PAID_ATTACK		= 0x400000,
	EA_PAID_BLOCK		= 0x800000,
	EA_FORCE_ATTACK		= 0x1000000,
	EA_BEFORE_COMBAT	= 0x2000000,
	EA_DECLARE_ATTACK	= 0x4000000,
	EA_FELLWAR_STONE	= 0x8000000,
	EA_CONTROLLED		= 0x10000000,	// EVENT_CARDCONTROLLED is only sent if there's at least one card in play with this set
	// End of bits checked in event_flags.

	EA_UNK20000000		= 0x20000000,	// Completely unused.
#ifndef SHANDALAR
	EA_PLAY_COST		= 0x40000000,	// If set, this specific card receives EVENT_MODIFY_COST_GLOBAL events to change other spells' casting costs.
#else
	EA_MODIFY_COST_GLOBAL=0x40000000,	// In Shandalar, EVENT_MODIFY_COST_GLOBAL is sent to all cards if any on the bf have this bit set.  Like EA_MARTYR - EA_CONTROLLED, it's set in event_flags at the end of get_abilities(...EVENT_CHANGE_TYPE).
#endif
	EA_ABILITY_COST		= 0x80000000,
} extra_abilities_t;

#ifdef SHANDALAR
enum mana_flags_t: uint8_t
{
	MANA_0							= 0,
	MANA_SPEND_ONLY_BLACK_MANA_ON_X	= 0x1,
};
STATIC_ASSERT(sizeof(mana_flags_t) == 1, mana_flags_t_enum_wrong_size);
#endif

typedef enum
{
  CP_COLOR_LESS		= 0,
  CP_COLOR_BLACK	= 1,
  CP_COLOR_BLUE		= 2,
  CP_COLOR_ARTIFACT	= 3,
  CP_COLOR_MULTI	= 4,
  CP_COLOR_GREEN	= 5,
  CP_COLOR_LAND		= 6,
  CP_COLOR_RED		= 7,
  CP_COLOR_WHITE	= 8,
  CP_COLOR_SPECIAL	= -1
} CardPtrClr;

typedef enum
{
  CP_TYPE_NONE			= 0,
  CP_TYPE_ARTIFACT		= 1,
  CP_TYPE_ENCHANTMENT	= 2,
  CP_TYPE_INSTANT		= 3,
  CP_TYPE_INTERRUPT		= 4,
  CP_TYPE_LAND			= 5,
  CP_TYPE_SORCERY		= 6,
  CP_TYPE_CREATURE		= 7,
  CP_TYPE_TOKEN			= 8,
  CP_TYPE_PLANESWALKER	= 9,	// unused
  CP_TYPE_SCHEME		= 10,	// unused
  CP_TYPE_PLANE			= 11	// unused
} CardPtrType;

/* Data struct */
typedef struct
{
	PRIVATE_IN_SHANDALAR(uint32_t id;)
	char*    full_name;
	char*    name;
	uint32_t expansion;
	uint32_t color;		// 1:black 2:blue 3:artifact 4:gold 5:green 6:land 7:red 8:white
	uint32_t card_type;	// 1:artifact 2:enchantment 3:instant 4:interrupt 5:land 6:sorcery 7:creature 8:token
	uint16_t subtype1; /* 0x18 == 24 */
	uint16_t subtype2;
	const char* type_text;	// e.g. "Legendary Creature - Human"
	uint32_t db_card_type_2;	// 1:ante 2:cardstealer 3:counter 4:directdamage 5:discard 6:drawer 7:lifegain 8:damageprevention 9:anti-land 10:manasource 11:bounce/untap/tap 12:pump
	uint32_t rarity;	// 1:common 2:rare 3:dungeon/astral/promotional 4:uncommon (sic)
	uint8_t req_colorless;
	uint8_t req_black;
	uint8_t req_blue;
#ifdef SHANDALAR
	uint8_t req_hybrid;
	uint8_t hybrid_colors;
#else
	uint8_t unknown43;
	uint8_t unknown44;
#endif
	uint8_t req_green;
#ifdef SHANDALAR
	mana_flags_t mana_flags;
#else
	uint8_t unknown46;
#endif
	uint8_t req_red;
	uint8_t req_white;
	uint8_t unknown0x49[15];
	const char* artist;		// Always "None"
	uint32_t num_pics;
	const char* mana_cost_text;	// e.g. "|4|GU|GU"
	uint32_t ai_modifiers1;
	uint32_t ai_modifiers2;
	uint8_t ai_inc_power;
	uint8_t ai_inc_toughness;
	uint8_t ai_power;
	uint8_t ai_toughness;
	int16_t ai_base_value;
	int16_t ai_dependencies;         //deck constructor only
	int32_t sleight_color;			// csv2dat doesn't seem to put anything here
	int16_t ai_against_color;        //deck constructor only
	int16_t ai_for_color;            //deck constructor only
	int16_t ai_counts_as_color;      //deck constructor only
	int16_t ai_against_land;         //deck constructor only
	int16_t ai_for_land;             //deck constructor only
	int16_t ai_counts_as_land;       //deck constructor only
	int32_t ai_abilities;            //deck constructor only
	int32_t expansion_rarity;
	char*   rules_text;
	char*   flavor_text;
	int32_t power;
	int32_t toughness;
	int16_t types[7];
	PRIVATE_IN_SHANDALAR(int8_t  mana_source_colors;)
	int8_t  inflatable;
	uint8_t hack_colors;	// In Shandalar: color_test_t of |Hlandtypes appearing in rules text or type text
	uint8_t currently_zero_for_all_cards;
	uint8_t enchant_type;	// // bits 0-3: Enchant Type OWN; bits 4-7: Enchant Type OPP.  In Shandalar: zero.
	uint8_t hack_mode;		// In Shandalar: zero
#ifdef SHANDALAR
	csvid_t csvid(void) const	{ return csvid_t(id); }
	void set_csvid(csvid_t csvid_val)	{ id = csvid_val.raw & 0xFFFF; }

	color_test_t mana_colors(void) const			{ return static_cast<color_test_t>(static_cast<uint8_t>(mana_source_colors)); }
	color_test_t set_mana_colors(color_test_t val)	{ return static_cast<color_test_t>(static_cast<uint8_t>(mana_source_colors = val)); }
#endif
	} PACKED card_ptr_t; /* need better name here */

typedef struct
{
	const char* damage_text;		// text of damage cards
	const char* effect_title_text;	// title of csvid==903 effect cards, per create_legacy_effect()
	const char* effect_text;		// text of csvid==903 effect cards
	const char* legacy_title_text;	// title of csvid==902 effect cards, per create_legacy_activate()
	const char* legacy_text;		// text of csvid==902 effect cards
} card_txt_t;

/* Parameters and enumerator for "global_tutor" and similar functions */
typedef struct
{
	char message[100];
	unsigned int type;
	unsigned int subtype;
	unsigned short int type_flag;
	unsigned short int subtype_flag;
	unsigned int color;
	int id;
	int id2;
	unsigned short int color_flag;
	unsigned short int id_flag;
	int cmc;
	unsigned int keyword;
	unsigned short int cmc_flag;
	unsigned short int keyword_flag;
	int power;
	int toughness;
	unsigned short int power_flag;
	unsigned short int toughness_flag;
	unsigned int state;
	unsigned int zone;
	unsigned short int state_flag;
	unsigned short int not_me;
	unsigned short int ai_selection_mode;
	unsigned short int qty;
	unsigned int sub2;
	unsigned int sub3;
	unsigned int sub4;
	unsigned int sub5;
	unsigned short int no_shuffle;
	unsigned short int create_minideck;
	int (*special_selection_function)(int, int, int, int);// Internal id to parse, value to check contained in "value_for_special_selection_function", player, card (-1 if not a card in play/in hand/on the stack).  Return nonzero to pass, zero to fail.
	int value_for_special_selection_function;
	int16_t painters_servant_hack[2];
	unsigned char has_mana_to_pay_cmc;
	unsigned char can_legally_play;
	unsigned char owner;
} test_definition_t;

typedef enum
{
	ACT_KILL_BURY			= 1,	// mirrors kill_t
	ACT_KILL_DESTROY		= 2,	// mirrors kill_t
	ACT_KILL_SACRIFICE		= 3,	// mirrors kill_t
	ACT_KILL_REMOVE			= 4,	// mirrors kill_t
	ACT_BOUNCE				= 5,
	ACT_TAP					= 6,
	ACT_UNTAP				= 7,
	ACT_RFG_UNTIL_EOT		= 16,
	ACT_KILL_STATE_BASED_ACTION	= 17,	// mirrors kill_t
	ACT_PUT_ON_TOP			= 40,
	ACT_PUT_ON_BOTTOM		= 41,
	ACT_DISABLE_NONMANA_ACTIVATED_ABILITIES	= 42,
	ACT_ENABLE_NONMANA_ACTIVATED_ABILITIES	= 43,
	ACT_HUMILIATE			= 44,
	ACT_DE_HUMILIATE		= 45, // This one remove the effect of ACT_HUMILIATE
	ACT_MAKE_UNTARGETTABLE	= 46,
	ACT_REMOVE_UNTARGETTABLE= 47,
	ACT_RESET_ADDED_SUBTYPE	= 48,
	ACT_DISABLE_ALL_ACTIVATED_ABILITIES	= 49,
	ACT_ENABLE_ALL_ACTIVATED_ABILITIES	= 50,
	ACT_GET_COUNT			= 51,
	ACT_GAIN_CONTROL		= 52,
	ACT_DOES_NOT_UNTAP		= 53,
	ACT_PHASE_OUT			= 54,
	ACT_OF_TREASON			= 55,
	ACT_DETAIN				= 56,

	ACT_PARAMETERIZED_ACTIONS_MASK = 0xFF000000,

	ACT_ADD_COUNTERS_BASE	= 0x01000000,
#define ACT_ADD_COUNTERS(counter_type, num)		(ACT_ADD_COUNTERS_BASE | (((counter_type) & 0xFF) << 16) | ((num) & 0xFFFF))
	ACT_REMOVE_COUNTERS_BASE= 0x02000000,
#define ACT_REMOVE_COUNTERS(counter_type, num)	(ACT_REMOVE_COUNTERS_BASE | (((counter_type) & 0xFF) << 16) | ((num) & 0xFFFF))
} actions_t;

// Flags shared by Manipulate All, Global Tutor, New Global Tutor, Damage All, New Damage all
typedef enum
{
	// good for all fields
	MATCH = 0,
	DOESNT_MATCH = 1,

	// ai selection mode flags
	AI_MAX_VALUE = 1,
	AI_MAX_CMC = 2,
	AI_MIN_VALUE = 3,
	AI_MIN_CMC = 4,
	AI_FIRST_FOUND = 5,
	AI_GOOD_TO_PUT_IN_GRAVE = 6,//If there isn't a suitable card (choosen via the "good_to_put_in_grave" function), it's the same as AI_MAX_CMC
	AI_RANDOM = 7,

	// The following must be summed to Ai selection mode in order to activate the appropriate flags
	DOES_NOT_SHUFFLE = 10,

	// Type specific flags
	F1_NO_CREATURE = 2,
	F1_NO_TOKEN = 3,
	F1_NO_PWALKER = 4,
//	F1_IS_LEGENDARY = 5,
	F1_IS_TOKEN = 6,
//	F1_HAS_FLASHBACK = 7,
//	F1_ARTIFACT_CREATURE = 8,
	F1_NONARTIFACT_CREATURE = 9,
	F1_MATCH_OR_FLASH = 10,
	F1_MATCH_ALL = 11,	/* The examined card must have every type specified in test_definition_t::type, e.g. TYPE_ARTIFACT|TYPE_CREATURE would pass only for
						 * artifact creatures (as opposed to passing for everything that's an artifact or a creature, which is what MATCH does).  It would also
						 * still pass for enchantment artifact creatures (like the enchantment golems Hammer of Purphoros makes) and land artifact creatures
						 * (like animated Mishra's Factories), of course. */

	// Subtype specific flags
	F2_MULTISUBTYPE = 3,		// must have any of ->subtype, sub2, sub3, sub4, or sub5 that are set
	F2_MULTISUBTYPE_ALL = 4,	// must have all of ->subtype, sub2, sub3, sub4, or sub5 that are set

	// Colors specific flags
	F3_MULTICOLORED = 2,
	F3_MONOCOLORED = 3,

	// ID specific flags
	F4_TOKEN_W_SPECIAL_INFOS = 3,
	F4_DOUBLE_ID_TUTOR = 4,

	// CMC/power/toughness specific flags
	F5_CMC_GREATER_THAN_VALUE = 2,
	F5_POWER_GREATER_THAN_VALUE = 2,
	F5_TOUGHNESS_GREATER_THAN_VALUE = 2,
	F5_CMC_LESSER_THAN_VALUE = 3,
	F5_POWER_LESSER_THAN_VALUE = 3,
	F5_TOUGHNESS_LESSER_THAN_VALUE = 3,

	// For power only
	F5_POWER_1_1_COUNTERS_GREATER_THAN_VALUE = 4,

	// Keyword flags
	F0_HAS_SP_KEYWORD = 2,			// Check keyword against sp_keyword_t instead of keyword_t.  Only works for cards in play.
	F0_DOESNT_HAVE_SP_KEYWORD = 3,	// Check keyword against sp_keyword_t instead of keyword_t.  Only works for cards in play.
} test_flags_t;

// Flags specific for New Damage All "mode".
typedef enum
{
	NDA_ALL_CREATURES	= 0x1,
	NDA_PLAYER_TOO		= 0x2,
	NDA_NOT_TO_ME		= 0x4,
	NDA_EXILE_IF_FATALLY_DAMAGED	= 0x8,
	NDA_CANT_REGENERATE_IF_DEALT_DAMAGE_THIS_WAY	= 0x10,
} nda_mode_flags_t;

// Flags for (damage card instance)->targets[3].card
typedef enum
{
	DMG_CANT_REGENERATE_IF_DEALT_DAMAGE_THIS_WAY	= 0x10,
} dmg_t;

/* Rarity */
typedef enum
{
	NONE		= 0,
	COMMON		= 1,
	UNCOMMON	= 2,
	RARE		= 3,
	MYTHIC		= 4,
	LAND		= 5,
	SPECIAL		= 6,
//	UNUSED		= 7,
} rarity_t;

/* Flags for damage_dealt_by_me(), subtype_deals_damage(), and damage_dealt_to_me_arbitrary().  New values must be either handled or asserted by all three. */
typedef enum
{
	DDBM_TRIGGER_OPTIONAL			= (1<<0),
	DDBM_MUST_DAMAGE_OPPONENT		= (1<<1),
	DDBM_MUST_BE_COMBAT_DAMAGE		= (1<<2),
	DDBM_REPORT_DAMAGE_DEALT		= (1<<3),

	// These three may be combined freely - if any are present, damage must be dealt to one of the named categories
	DDBM_MUST_DAMAGE_PLAYER			= (1<<4),
	DDBM_MUST_DAMAGE_CREATURE		= (1<<5),
	DDBM_MUST_DAMAGE_PLANESWALKER	= (1<<6),

	DDBM_NOT_ME						= (1<<7),
	DDBM_TRACE_DAMAGED_CREATURES	= (1<<8),
	DDBM_TRACE_DAMAGED_PLAYERS		= (1<<9),
	DDBM_STORE_IN_TARGETS_9			= (1<<10),	// Instead of the default targets[8].player, which, brilliantly, is the same place as equipment.
} ddbm_flags_t;

/* Trap conditions  */
typedef enum {
	// Some of these are always recorded, so long as a Rules Engine card is controlled by the appropriate player.
	// Some only if REF_TRAP_CONDITIONS is set.  STORM_[color] ones only if REF_STORM_COUNT is.

	// Values 0x000-0x003: One short of storage for each, cleared at the start of each turn.
#define TRAP_MIN_SHORTS_PER_TURN		0x000
	TRAP_DAMAGE_TAKEN					= 0x000,	// Always recorded.
	TRAP_LIFE_GAINED					= 0x001,	// Always recorded.
	TRAP_LIFE_LOST						= 0x002,	// Always recorded.
	TRAP_ARTIFACT_DAMAGE_TAKEN			= 0x003,	// Always recorded.
#define TRAP_MAX_SHORTS_PER_TURN		0x003
#define TRAP_NUMSHORTS_SHORTS_PER_TURN	(TRAP_MAX_SHORTS_PER_TURN - TRAP_MIN_SHORTS_PER_TURN + 1)

	// Values 0x100 through 0x100: One byte of storage for each, not cleared.
#define TRAP_MIN_SHORTS_PERSISTENT	0x100
#define TRAP_MAX_SHORTS_PERSISTENT	0x100
#define TRAP_NUMSHORTS_SHORTS_PERSISTENT	(TRAP_MAX_SHORTS_PERSISTENT - TRAP_MIN_SHORTS_PERSISTENT + 1)

	// Values 0x200-0x21F: One byte of storage for each, cleared at the start of each turn.
#define TRAP_MIN_BYTES_PER_TURN		0x200
	TRAP_DEAD_ZUBERA_COUNT				= 0x200,
	//0x201 unused
	TRAP_CARDS_TO_GY_FROM_ANYWHERE		= 0x202,
	TRAP_DISCARDED_CARDS				= 0x203,
	TRAP_UNBLOCKED_CREATURES			= 0x204,
	TRAP_MAX_DAMAGE_DEALT				= 0x205,
#define TRAP_MAX_BYTES_PER_TURN		0x20F
#define TRAP_NUMBYTES_BYTES_PER_TURN	(TRAP_MAX_BYTES_PER_TURN - TRAP_MIN_BYTES_PER_TURN + 1)

	// Values 0x300 through 0x301: One byte of storage for each, not cleared.
#define TRAP_MIN_BYTES_PERSISTENT	0x300
	TRAP_TURN_COUNT						= 0x300,
#define TRAP_MAX_BYTES_PERSISTENT	0x301
#define TRAP_NUMBYTES_BYTES_PERSISTENT	(TRAP_MAX_BYTES_PERSISTENT - TRAP_MIN_BYTES_PERSISTENT + 1)

	// Values 0x400 through 0x40F: Four bits of storage for each (so can store 0-15), cleared at the start of each turn.
#define TRAP_MIN_NYBBLES_PER_TURN	0x400
	TRAP_ARTIFACTS_PLAYED				= 0x400,	// Number of artifacts that entered the battlefield.
	TRAP_CREATURES_PLAYED				= 0x401,	// As above.  For creature spells cast this turn, use get_stormcreature_count().
	TRAP_LANDS_PLAYED					= 0x402,	// As above.  For lands actually played this turn (by anyone), use lands_played.
	TRAP_STORM_BLACK					= 0x403,	// Relies on these being in the same order as color_t.
	TRAP_STORM_BLUE						= 0x404,
	TRAP_STORM_GREEN					= 0x405,
	TRAP_STORM_RED						= 0x406,
	TRAP_STORM_WHITE					= 0x407,
	TRAP_COT_FLAG						= 0x408,
#define TRAP_MAX_NYBBLES_PER_TURN	0x40F
#if ((TRAP_MAX_NYBBLES_PER_TURN - TRAP_MIN_NYBBLES_PER_TURN + 1) % 2) != 0
#  error "Number of nybbles per turn must be a multiple of 2"
#endif
#define TRAP_NUMBYTES_NYBBLES_PER_TURN	((TRAP_MAX_NYBBLES_PER_TURN - TRAP_MIN_NYBBLES_PER_TURN + 1) / 2)

	/* Values 0x500 would be persistent nybbles, but they seem unlikely to be useful - anything worth keeping longer than a turn probably either needs a higher
	 * max or is ok with a bit.) */

	// Values 0x600 through 0x60F: One bit of storage for each, cleared at the start of each turn.
#define TRAP_MIN_BITS_PER_TURN		0x600
	TRAP_DECK_WAS_SEARCHED				= 0x600,
	TRAP_PROWL_ROGUE					= 0x601,	// Combat damage dealt to a player by a Rogue creature; always recorded
	TRAP_PROWL_GOBLIN					= 0x602,	// Combat damage dealt to a player by a Goblin creature; always recorded
	TRAP_CHANDRAS_PHOENIX				= 0x603,	// Dealt damage to an opponent with a red instant, sorcery, or planeswalker; always recorded
	TRAP_PERMAFROST_TRAP				= 0x604,
	TRAP_DAMAGED_BY_CREATURE			= 0x605,	// Combat damage taken from any creature; always recorded
	TRAP_RAID							= 0x606,
//	TRAP_COT_FLAG						= 0x607,
	TRAP_SUMMONING_TRAP					= 0x608,
	TRAP_PROWL_FAERIE					= 0x609,	// Combat damage dealt to a player by a Faerie creature; always recorded
	TRAP_PEER_THROUGH_DEPTHS			= 0x60A,
	TRAP_REACH_THROUGH_MISTS			= 0x60B,
#define TRAP_MAX_BITS_PER_TURN		0x61F
#if ((TRAP_MAX_BITS_PER_TURN - TRAP_MIN_BITS_PER_TURN + 1) % 8) != 0
#  error "Number of bits per turn must be a multiple of 8"
#endif
#define TRAP_NUMBYTES_BITS_PER_TURN	((TRAP_MAX_BITS_PER_TURN - TRAP_MIN_BITS_PER_TURN + 1) / 8)

	// Values 0x700 through 0x707: One bit of storage for each, not cleared.
#define TRAP_MIN_BITS_PERSISTENT		0x700
//										= 0x700, Unused
//										= 0x701, Unused
	TRAP_HOMING_SLIVER					= 0x702,
	TRAP_CHALLENGE_EPIC					= 0x703,
	TRAP_FIRST_TURN_UPKEEP				= 0x704,
#define TRAP_MAX_BITS_PERSISTENT		0x707
#if ((TRAP_MAX_BITS_PERSISTENT - TRAP_MIN_BITS_PERSISTENT + 1) % 8) != 0
#  error "Number of bits per turn must be a multiple of 8"
#endif
#define TRAP_NUMBYTES_BITS_PERSISTENT	((TRAP_MAX_BITS_PERSISTENT - TRAP_MIN_BITS_PERSISTENT + 1) / 8)
} traps_t;

/* flags for "generic_activated_ability" mode  */
typedef enum
{
	GAA_NONE					= 0,
	GAA_UNTAPPED				= 1<<0,
	GAA_NONSICK					= 0,	// Always assumed if GAA_TAPPED or GAA_UNTAPPED is set
	GAA_LITERAL_PROMPT			= 1<<1,	// Don't load_text for prompt in GAA_CAN_TARGET
	GAA_CAN_TARGET				= 1<<2,
	GAA_SACRIFICE_ME			= 1<<3,
	GAA_CAN_SORCERY_BE_PLAYED	= 1<<4,
	GAA_DISCARD					= 1<<5,
	GAA_1_1_COUNTER				= 1<<6,
	GAA_MINUS1_MINUS1_COUNTER	= 1<<7,

	GAA_SACRIFICE_CREATURE		= 1<<9,
	GAA_SPELL_ON_STACK			= 1<<10,

	GAA_ONCE_PER_TURN					= 1<<13,
	GAA_RFG_ME							= 1<<14,
	GAA_ONLY_ON_UPKEEP					= 1<<15,
	GAA_IN_YOUR_TURN					= 1<<16,
	GAA_BOUNCE_ME						= 1<<17,
	GAA_NOT_ME_AS_TARGET				= 1<<18,
	GAA_TAPPED							= 1<<19,
	GAA_DECK_SEARCHER					= 1<<20,

	GAA_CAN_ONLY_TARGET_OPPONENT		= 1<<22,
	GAA_REGENERATION					= 1<<23,
	GAA_DAMAGE_PREVENTION				= 1<<24,
	GAA_DAMAGE_PREVENTION_PLAYER		= 1<<25,
	GAA_DAMAGE_PREVENTION_CREATURE		= 1<<26,
	GAA_DAMAGE_PREVENTION_ME			= 1<<27,
	GAA_BEFORE_ATTACKERS				= 1<<28,
	GAA_DISCARD_RANDOM					= 1<<29,
	GAA_IN_OPPONENT_TURN				= 1<<30,
	GAA_TYPE_CHANGE						= 1<<31,

	// This must be set in the variable_costs parameter, not mode.
#define GVC_COUNTERS(counter_type, number)	(0x01000000 | (((counter_type) & 0xFF) << 16) | (((number) & 0xFF) << 8))
#define GVC_COUNTER(counter_type)			GVC_COUNTERS(counter_type, 1)
	// And this version also sets an amount of life to pay.
#define GVC_COUNTERS_AND_LIFE(counter_type, number, life)	(GVC_COUNTERS(counter_type, number) | ((life) & 0xFF))

} generic_activated_ability_flags_t;

/* flags for "generic_spell" */
typedef enum
{
	GS_CAN_TARGET				= 1<<0,
	GS_COUNTERSPELL				= 1<<1,
	GS_X_SPELL					= 1<<2,
	GS_GRAVE_RECYCLER			= 1<<3,
	GS_REGENERATION				= 1<<4,
	GS_OPTIONAL_TARGET			= 1<<5,
	GS_CAN_ONLY_TARGET_OPPONENT	= 1<<6,
	GS_LITERAL_PROMPT			= 1<<7,	// Don't load_text for prompt in GS_CAN_TARGET or GS_GRAVE_RECYCLER
	GS_DAMAGE_PREVENTION		= 1<<8,
	GS_AURA						= 1<<9,
	GS_SAC_CREATURE_AS_COST		= 1<<10,
	GS_GRAVE_RECYCLER_OPP_GRAVE	= 1<<11,
	GS_GRAVE_RECYCLER_BOTH_GRAVES = 1<<12,
} generic_spell_flags_t;

/* Special flags  - Generic flags */
typedef enum
{
	SF_LETHAL_DAMAGE_DESTROY= 1<<0,	// Target has been dealt damage by a source with deathtouch, and will be destroyed when it resolves
	SF_WONT_RECEIVE_DAMAGE	= 1<<1,
	SF_TYPE_ALREADY_CHANGED	= 1<<2,
	SF_LETHAL_DAMAGE_BURY	= 1<<3,	// Target has been dealt combat damage by a source with deathtouch and a no-regen effect (probably Phage the Untouchable), and will be buried when it resolves
	SF_FLANKING_REMOVED		= 1<<4,
	SF_ECHO_TO_PAY			= 1<<5,
	SF_ATTACKING_PWALKER	= 1<<6,
	SF_KICKED				= 1<<7,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF_KICKED2				= 1<<8,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF_LETHAL_DAMAGE_EXILE	= 1<<9,	// Target has been dealt damage by a source that exiles on damage like Pit Spawn, and will be exiled when it resolves
	SF_CANNOT_PHASE_OUT		= 1<<10,
	SF_KILL_STATE_BASED_ACTION	= 1<<11,	// A permanent being put into a graveyard as a state-based action.  Handled internally as KILL_SACRIFICE.  This flag lets things triggering on cards-being-sacrificed, like It That Betrays, know that it's not really a sacrifice.
	SF_JUST_CAME_INTO_PLAY	= 1<<12,
	SF_DAMAGED_PLAYER		= 1<<13,
	SF_UNEARTH				= 1<<14,
	SF_MODULAR				= 1<<15,	// Must be set continuously during EVENT_ABILITIES.
	SF_PLAYED_FROM_DECK		= 1<<16,
	SF_HEXPROOF_OVERRIDE	= 1<<17,	// Must be set continuously during EVENT_ABILITIES.
	SF_NOT_CAST				= 1<<18,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF_PLAYED_FOR_FREE		= 1<<19,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF_EXILE_ON_RESOLUTION	= 1<<20,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF_ECHO_PAID			= 1<<21,
	SF_MANA_PRODUCER_DISABLED_FOR_AI	= 1<<22,
	SF_MOVE_AURA_LEGAL_TARGET			= 1<<23,
	SF_MOVE_AURA_SAME_CONTROLLER		= 1<<24,
	SF_CORRECTLY_RESOLVED				= 1<<25,
	SF_PHASED_OUT						= 1<<26,
	SF_PHASED_OUT_INDIRECTLY			= 1<<27,
	SF_PLAYED_FROM_GRAVE				= 1<<28,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF_TARGETS_ALREADY_SET				= 1<<29,
	SF_DONT_COPY_TOKEN_SOURCE			= 1<<30,	// If this token is copied, don't set the copy's source
	SF_PLAYED_FROM_EXILE				= 1<<31,	// Misplaced; only permanents should have these flags, since they overlap the targets array
} special_flags_t;

/* Special flags  2*/
typedef enum
{
	SF2_KIRA_GREAT_GLASS_SPINNER	= 1<<0,
	SF2_SOULFIRE_GRAND_MASTER		= 1<<1,
	SF2_MYCOSYNTH_LATTICE			= 1<<2,		// Must be set continuously during EVENT_CHANGE_TYPE.
	SF2_CELESTIAL_DAWN				= 1<<3,
	SF2_KATABATIC_WINDS				= 1<<4,
	SF2_PRISMATIC_OMEN				= 1<<5,
	SF2_CONTAMINATION				= 1<<6,
	SF2_ENCHANTED_EVENING			= 1<<7,		// Must be set continuously during EVENT_CHANGE_TYPE.
	SF2_FACE_DOWN_DUE_TO_MANIFEST	= 1<<8,
	SF2_INFINITE_REFLECTION			= 1<<9,		// Also used for Essence of the Wild - flags permanents as cloning cards
	SF2_TEMPORARY_COPY_OF_TOKEN		= 1<<10,	// Don't apply token_characteristic_setting_effects() to this token from this source.  May be set either on tokens themselves or on effects that apply a token's characteristics; for tokens, must be set continuously during EVENT_CHANGE_TYPE.
	SF2_MONSTROUS					= 1<<11,
	SF2_THOUSAND_YEAR_ELIXIR		= 1<<12,	// Must be set continuously during EVENT_ABILITIES.
	SF2_MISDIRECTION				= 1<<13,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF2_QUICKSILVER_DRAGON			= 1<<14,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF2_REBOUND						= 1<<15,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF2_SPELLSKITE					= 1<<16,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF2_X_SPELL						= 1<<17,	// Misplaced; only permanents should have these flags, since they overlap the targets array
	SF2_PAIRED						= 1<<18,
	SF2_GOBLIN_ARTISANS				= 1<<19,
	SF2_ENCHANTMENT_ALTERATION		= 1<<20,
	SF2_SOULBOND					= 1<<21,
	SF2_CANNOT_BE_SACRIFICED		= 1<<22,
	SF2_QUARUM_TRENCH_GNOMES		= 1<<23,
	SF2_COMMANDER					= 1<<24,
	SF2_COULD_NOT_UNTAP				= 1<<25,
	SF2_HAS_DAMAGED_PLAYER0			= 1<<26,
	SF2_HAS_DAMAGED_PLAYER1			= 1<<27,
	SF2_WILL_BE_EXILED_IF_PUTTED_IN_GRAVE = 1<<28,
	SF2_DEEP_WATER					= 1<<29,
	SF2_REFLECTING_MIRROR			= 1<<30,
	SF2_COPIED_FROM_STACK			= 1<<31,
} special_flags2_t;

/* Special flags  3*/
typedef enum
{
	SF3_REANIMATED					= 1<<0,
	SF3_MANACOST_NULLIFIED			= 1<<1,
	SF3_ENCHANTED_PERMANENT_DYING	= 1<<2,
	SF3_MOVING_AURA_PLAYER0_SELECT_TARGET	= 1<<3,
	SF3_RENOWNED					= 1<<4,
} special_flags3_t;

// Parameters for token_generation_t::action
typedef enum
{
	TOKEN_ACTION_TAPPED		= 1<<0,	// Token is put into play tapped
	TOKEN_ACTION_ATTACKING_UNTAPPED	= 1<<1,	// Token is put into play attacking but not tapped
	TOKEN_ACTION_ATTACKING	= TOKEN_ACTION_TAPPED|TOKEN_ACTION_ATTACKING_UNTAPPED,	// Token is put into play tapped and attacking
	TOKEN_ACTION_EQUIP		= 1<<2,	// Equip source player/card to the (first) generated token.
	TOKEN_ACTION_HASTE		= 1<<3,	// Token gets haste until end of turn.  s_key_plus can set it permanently, but only on token-only cards.
	TOKEN_ACTION_DONT_COPY_TOKEN_SOURCE	= 1<<4,	// If this token is copied, don't set the copy's source
	TOKEN_ACTION_CONVERT_INTO_ARTIFACT	= 1<<5,	// Used by Feldon of the Third Way

	// The following all use action_argument, so are incompatible with each other (except for TOKEN_ACTION_PUMP_POWER, which can combine with TOKEN_ACTION_PUMP_TOUGHNESS)
	TOKEN_ACTION_BLOCKING	= 1<<16,	// Token is put into play blocking action_argument.
	TOKEN_ACTION_PUMP_POWER	= 1<<17,	// Token gets +X/+0 until end of turn.  X is action_argument.  (Not actually used by anything.)
	TOKEN_ACTION_PUMP_TOUGHNESS	= 1<<18,	// Token gets +0/+X until end of turn.  X is action_argument.  (Not actually used by anything.)
	TOKEN_ACTION_ADD_SUBTYPE= 1<<19,	// Add subtype in action_argument to token.
} token_action_t;

/* Parameters for "generate_token" and such */
typedef struct struct_token_generation_t	// struct name only for forward declaration
{
	// Most of these are only safe with token-only cards (e.g., CARD_ID_SOLDIER).  Exceptions noted below.
	int id;	// A csvid.  Usable with nontokens (though it's already set by default_token_definition() for you)
	int s_player;	// Player/card that originally created this token, or the token this was copied from.  Should not be set directly.
	int s_card;		// (part of above)
	int eff_player;	// Player/card currently creating this token.  Should not be set directly.
	int eff_card;	// (part of above)
	int t_player;	// Player currently receiving this token.  Should not be set directly.
	int pow;
	int tou;
	unsigned int key_plus;
	unsigned int s_key_plus;
	unsigned char color_forced;
	unsigned char no_sleight;
	unsigned char legacy;	// Usable with nontokens
	unsigned char qty;
	unsigned int special_infos;
	token_action_t action;	// Usable with nontokens
	int action_argument;	// Usable with nontokens
	unsigned int keep_track_of_tokens_generated;	// Usable with nontokens.  Set to the maximum number of targets in s_player/s_card to set (e.g. setting to 19 will use targets[0]-targets[18]); after generate_token() is called, this will have been set to the actual number used.  Be aware that the returned tokens may no longer be valid due to come-into-play effects.  Avoid using if at all possible.
	int (*special_code_for_legacy)(int, int, event_t);	// Usable with nontokens
	void (*special_code_on_generation)(struct struct_token_generation_t*, int, int);	// If set, this is called for each token before it's put in play.  It gets passed the token_generation_t structure, the idx of the card_added, and which number token this is (starting from 0).
	int special_flags2;
} token_generation_t;

/* Flags for "check_battlefield_for_special_card */
typedef enum
{
	CBFSC_CHECK_ONLY	= 0,	//Only one of this parameters could be used when calling the function
	CBFSC_AI_MAX_VALUE	= 1<<0, //Only one of this parameters could be used when calling the function
	CBFSC_AI_MIN_VALUE	= 1<<1,	//Only one of this parameters could be used when calling the function
	CBFSC_GET_COUNT		= 1<<2,	//Only one of this parameters could be used when calling the function
	CBFSC_LEGAL_TARGET	= 1<<3,	//Deprecated
	CBFSC_GET_TOTAL_TOU	= 1<<4,	//Only one of this parameters could be used when calling the function
	CBFSC_EXCLUDE_ME	= 1<<5,	//Deprecated
	CBFSC_GET_TOTAL_POW	= 1<<6,	//Only one of this parameters could be used when calling the function
	CBFSC_GET_MAX_POW	= 1<<7,	//Only one of this parameters could be used when calling the function
	CBFSC_GET_MAX_TOU	= 1<<8,	//Only one of this parameters could be used when calling the function
	CBFSC_GET_MAX_CMC	= 1<<9,	//Only one of this parameters could be used when calling the function
	CBFSC_GET_MIN_CMC	= 1<<10,//Only one of this parameters could be used when calling the function
	CBFSC_GET_TOTAL_CMC	= 1<<11,//Only one of this parameters could be used when calling the function

} cbfsc_flags_t;

/* Modes for "get_dead_count" */
typedef enum
{
	// for the other values, just use the TYPE_ definitions - TYPE_LAND through TYPE_ARTIFACT, TARGET_TYPE_PLANESWALKER, and TARGET_TYPE_TOKEN.
	GDC_NONPLANESWALKER	= 1<<30,	// reject if a planeswalker, even if all of TYPE_LAND, TYPE_CREATURE, TYPE_ENCHANTMENT, and TYPE_ARTIFACT are set
	GDC_NONTOKEN		= 1<<31,	// reject if TARGET_TYPE_TOKEN is set
} gdc_flags_t;

/* Flags for Rules Engine */
typedef enum
{
	REF_LEYLINES						= 1<<0, // Also enables 'get_turn_count'
	REF_TRAP_CONDITIONS					= 1<<1,
	REF_STORM_COUNT						= 1<<2,
	REF_GAUNTLET						= 1<<3,
	REF_DREDGE							= 1<<4,
	REF_UPKEEP_ABILITY_IN_GRAVE			= 1<<5,
	REF_CONT_AND_TRIG_ABILITY_IN_GRAVE	= 1<<6,
	REF_BRIDGE_FROM_BELOW				= 1<<7,
	//1<<8 unused
	REF_KROVIKAN_HORROR					= 1<<9,
	REF_DISCARD_TRIGGER_MADNESS			= 1<<10,
	//1<<11 unused
	REF_ACTIVATED_ABILITIES_HAND_GRAVE	= 1<<12,
	REF_DEADBOX							= 1<<13,
	REF_VENGEFUL_PHARAOH				= 1<<14,
	REF_MIRACLES						= 1<<15,
	REF_FORECAST						= 1<<16,
	REF_SCAVENGE						= 1<<17,
	REF_AURA_RETURNING_FROM_GRAVE		= 1<<18,
	REF_CONSPIRE						= 1<<19,
	REF_RECOVER							= 1<<20,
	REF_BEGINNING_OF_COMBAT_EFFECTS		= 1<<22,
} re_flags_t;

/* Flags for ec_definition_t::effect */
typedef enum
{
	EC_DISCARD					= 1,
	EC_RFG						= 2,
	EC_KARN_LIBERATED			= 4,
	EC_SELECT_CARD				= 8,
	EC_DESPISE					= 16,
	EC_PUT_ON_TOP				= 32,
	EC_GERRARDS_VERDICT			= 64,
	EC_ALL_WHICH_MATCH_CRITERIA	= 128,
	EC_PUT_ON_BOTTOM			= 256,
} coercion_flags_t;

/* Parameters and enumerator for "new_effect_coercion" */
typedef struct
{
	int target_player;
	int who_choses;
	unsigned int effect;
	int cards_to_reveal;
	int qty;
	unsigned int ai_selection_mode;
	int (*special_selection_function)(int, int, int);//target_player, who_chooses, internal_id to parse
} ec_definition_t;

/* Flags for "effect_does_not_untap" */
typedef enum
{
	EDNT_REMAIN_TAPPED_UNTIL_SOURCE_LEAVES_PLAY	= 1<<0,
	EDNT_TAP_AT_END_OF_COMBAT					= 1<<1,
	EDNT_WONT_UNTAP_ANYMORE						= 1<<2,
	EDNT_TAP_TARGET								= 1<<3,
} ednt_flags_t;

typedef enum {
  STORM_CREATURE	= (1<<0),
  STORM_BLACK = COLOR_TEST_BLACK,
  STORM_BLUE = COLOR_TEST_BLUE,
  STORM_GREEN = COLOR_TEST_GREEN,
  STORM_RED = COLOR_TEST_RED,
  STORM_WHITE = COLOR_TEST_WHITE,
} storm_mode_t;

typedef enum{ // results from EVENT_GRAVEYARD_ABILITY
	GA_PLAYABLE_FROM_GRAVE			= 1<<0, // the default case, used by almost all the cards with Flashback
	GA_RETURN_TO_HAND				= 1<<1,
	GA_RETURN_TO_PLAY				= 1<<2,
	GA_UNEARTH						= 1<<3,
	GA_BASIC						= 1<<4, // a standard GAA ability, that could be used multiple times when the card is in grave
	GA_SCAVENGE						= GA_BASIC | 1<<5,
	GA_RETURN_TO_PLAY_MODIFIED		= GA_RETURN_TO_PLAY | (1<<6),
	GA_RETURN_TO_PLAY_WITH_EFFECT	= GA_RETURN_TO_PLAY | (1<<7),
	GA_PUT_ON_TOP_OF_DECK			= 1<<8,
} graveyard_ability_type_t;

typedef enum{ // results from EVENT_PAY_FLASHBACK_COST
	GAPAID_REMOVE			= 1<<0, // Used for flashback and similar
	GAPAID_EXILE			= 1<<1, // Used for cards that have "exile this from grave:"
	GAPAID_REMAIN_IN_GRAVE	= 1<<2, //The card has an activated ability that could be used when in grave
} graveyard_ability_paid_t;

// Stuff required for "countering an activated ability", by Korath
typedef struct
{
  PRIVATE_IN_SHANDALAR(int16_t internal_card_id;)
  int8_t generating_event;
  int8_t unknown_sdt;           // seems to usually be a player.  I don't see anything that accesses it directly.
#ifdef SHANDALAR
  iid_t iid(void) const			{ return iid_t(internal_card_id); }
  void set_iid(iid_t iid_val)	{ internal_card_id = iid_val.raw; }
#endif
} PACKED stack_data_t;

typedef enum {
	// All of these are cleared at the end of each turn.
	EF_RERUN_DAMAGE_PREVENTION	= 1<<0,	/* Set if an effect run during regeneration/goes-to-graveyard triggers inflicts damage or destroys cards.  Seems to be
										 * checked only while resolving combat damage, and is only set by Volcanic Eruption, Abu Jafar, and War Barge. */
	EF_TRIGGER_END_PHASE		= 1<<1,	// TRIGGER_END_DRAW, TRIGGER_END_MAIN, and TRIGGER_END_DISCARD are sent only if this is set.  Nothing sets it, though.
	EF_MULTIBLOCKERS			= 1<<2,	// Turned on when a multiblocker card is created, and checked in AI combat functions.  Doesn't seem to work.
	EF_ATTACKER_CHOOSES_BLOCKERS= 1<<3,	// The attacker, not defender, chooses which creatures blocks  and how.

	EF_EA_MASK					= (EA_MARTYR|EA_SELECT_ATTACK|EA_SELECT_BLOCK|EA_LICH|EA_PAID_ATTACK|EA_PAID_BLOCK|EA_FORCE_ATTACK|EA_BEFORE_COMBAT
								   |EA_DECLARE_ATTACK|EA_FELLWAR_STONE|EA_CONTROLLED),
	/* After dispatching EVENT_CHANGE_TYPE for a card, all bits in its card_data_t::extra_ability also in EF_EA_MASK are set in event_flags.  They're mostly
	 * (all?) required to be set in event_flags for a corresponding event to be sent (such as EVENT_MUST_ATTACK for EA_FORCE_ATTACK).  Bits may be turned on
	 * manually in response to EVENT_CHANGE_TYPE if it's inappropriate to set them in ct_all.csv for some reason, such as it being an effect card. */
} event_flag_t;

typedef enum {
	GAMETYPE_SOLO_DUEL		= 1,
	GAMETYPE_GAUNTLET		= 2,
	GAMETYPE_SEALED_DECK	= 3,
} game_type_t;

typedef enum {
	LCBP_LAND_HAS_BEEN_PLAYED = 0x1,
	LCBP_PENDING_DAMAGE_CARDS = 0x2,	// There's a damage card in play attached to something that'll need to be resolved eventually by calling 0x477070.
	LCBP_DAMAGE_PREVENTION = 0x4,	// Turned on while resolving damage.
	TENTATIVE_LCBP_DURING_COMBAT = 0x8,
	LCBP_SPELL_BEING_PLAYED = 0x20,	// Makes only interrupts playable, etc.
	TENTATIVE_LCBP_DURING_EITHER_MAIN_PHASE = 0x80,
	TENTATIVE_LCBP_DURING_SECOND_MAIN_PHASE = 0x100,
	// All values above here are cleared at the start of each turn and the start of the first main phase.

	LCBP_REGENERATION = 0x200,	// Turned on while prompting for regeneration effects.
	LCBP_CARD_BEING_COPIED = 0x400,	// charge_mana() does nothing; fireball and drain life get their X from card_on_stack_controller/card_on_stack instead of x_value.  Turned on around the put_into_play() call in exe version of card_fork().
	LCBP_SKIP_TURN = 0x8000,	// skips the next turn (no matter whose it is)
	LCBP_NEED_EVENT_CHANGE_TYPE_SECOND_PASS = 0x10000,	// set this during EVENT_CHANGE_TYPE to indicate this card needs to be run a second time
	LCBP_DURING_EVENT_CHANGE_TYPE_SECOND_PASS = 0x20000,	// this is set during EVENT_CHANGE_TYPE's second dispatch
	// All other values unused.
} land_can_be_played_t;

typedef enum {
	PB_OPPONENT_CHECKS_ATTACK_LEGALITY	= 1<<0,	// Always dispatch EVENT_ATTACK_LEGALITY for the other player's creatures, even if no card with EA_DECLARE_ATTACK is on the battlefield.
	PB_SHANDALAR_LIBRARY_OF_LENG		= 1<<1,	// Suppresses discard phase; shoehorns Library of Leng's replacement effect into discard().  Set and works only in Shandalar.
	PB_COUNT_TOTAL_PLAYABLE_LANDS		= 1<<2,	// Set to recount number of playable lands in count_colors_of_lands_in_play().
	PB_SEND_EVENT_UNTAP_CARD_TO_ALL		= 1<<3,	// Set to make EVENT_UNTAP_CARD for this player's permanents be sent to all cards, not just the card being untapped.  Cleared just before EVENT_BEGIN_TURN each turn.  It's easiest and safest to set the bit continuously; that's reasonably cheap (much more so than getting a card instance or constructing a test_definition_t or target_definition_t), and robust in the face of changing card types, animation, and control.
	PB_CANT_HAVE_OR_GAIN_FIRST_STRIKE	= 1<<4,	// Archetype of Courage's ability - Creatures this player controls can't have or gain first strike.
	PB_CANT_HAVE_OR_GAIN_FLYING			= 1<<5,	// Archetype of Imagination
	PB_CANT_HAVE_OR_GAIN_DEATHTOUCH		= 1<<6,	// Archetype of Finality
	PB_CANT_HAVE_OR_GAIN_TRAMPLE		= 1<<7,	// Archetype of Aggression
	PB_CANT_HAVE_OR_GAIN_HEXPROOF		= 1<<8,	// Archetype of Endurance
	PB_HAND_REVEALED					= 1<<9,	// Set this during EVENT_STATIC_EFFECTS to make the player's hand visible.
	PB_SWAMPWALK_DISABLED				= 1<<10,
	PB_ISLANDWALK_DISABLED				= 1<<11,
	PB_FORESTWALK_DISABLED				= 1<<12,
	PB_MOUNTAINWALK_DISABLED			= 1<<13,
	PB_PLAINSWALK_DISABLED				= 1<<14,
	PB_NONSTANDARD_LANDWALK_DISABLED	= 1<<15,
	PB_LANDWALK_DISABLED_MASK			= PB_SWAMPWALK_DISABLED | PB_ISLANDWALK_DISABLED | PB_FORESTWALK_DISABLED | PB_MOUNTAINWALK_DISABLED | PB_PLAINSWALK_DISABLED | PB_NONSTANDARD_LANDWALK_DISABLED,
	PB_PLAYER_HAS_SHROUD				= 1<<16,
	PB_PLAYER_HAS_HEXPROOF				= 1<<17,
	PB_CAN_USE_PW_ABILITIES_AS_INSTANT	= 1<<18,
	PB_COMMANDER_IN_PLAY				= 1<<19,
	PB_CANT_HAVE_OR_GAIN_SHROUD			= 1<<20,	// Arcane Lighthouse
	PB_CANT_HAVE_OR_GAIN_ABILITIES_MASK = PB_CANT_HAVE_OR_GAIN_FIRST_STRIKE|PB_CANT_HAVE_OR_GAIN_FLYING|PB_CANT_HAVE_OR_GAIN_DEATHTOUCH|PB_CANT_HAVE_OR_GAIN_TRAMPLE|PB_CANT_HAVE_OR_GAIN_HEXPROOF|PB_CANT_HAVE_OR_GAIN_SHROUD,
} player_bits_t;

typedef enum {
	// 8 bits only.
	MANADRAIN_AMT_MASK = 0x3F,			// A specific amount of mana (up to 63) that doesn't drain until end of turn.  Takes precedence over MANADRAIN_BECOMES_COLORLESS.
	MANADRAIN_BECOMES_COLORLESS = 0x40,	// Mana of this color becomes colorless at end of phase instead of draining.  Don't set for mana_doesnt_drain_from_pool[*][COLOR_COLORLESS].
	MANADRAIN_DOESNT_DRAIN = 0x80,		// Mana of this color doesn't drain at end of phase - takes precedence over MANADRAIN_BECOMES_COLORLESS.
} mana_doesnt_drain_t;

typedef enum {
	// Bitfield of values for eot_toughness of the Asterisk effect card.

	// Whose permanents or cards to count.  Either or both may be set.
	ASTERISK_COUNT_CONTROLLER	= 0x1,
	ASTERISK_COUNT_OPPONENT		= 0x2,

	// Whether to affect power or toughness or both.
	ASTERISK_AFFECTS_POWER		= 0x4,
	ASTERISK_AFFECTS_TOUGHNESS	= 0x8,

	// What to count.  Exactly one must be set, even though the values are bitfield-like.
	// Most need an additional parameter in the effect card's info_slot (not that of the creature it's attached to).
	ASTERISK_BASICLAND_TYPES_OF_INFO_SLOT	= 0x100,	// Number of matching basic land types controlled.  COLOR_GREEN is forests, etc.
	ASTERISK_IID_OF_INFO_SLOT				= 0x200,	// info_slot is an internal_card_id; convert it to a csvid and count permanents with that.
	ASTERISK_POWER_IN_BYTE0_TOUGHNESS_IN_BYTE1_OF_INFO_SLOT	= 0x400,	// Set to specific values.  Not quite sufficient to implement Sorceress Queen's effect by itself.
	ASTERISK_NONWALL_CREATURES				= 0x800,	// Counts non-Wall creatures.
	ASTERISK_POWER_IN_BYTE0_TOUGHNESS_IN_BYTE1_MIN1_OF_INFO_SLOT	= 0x1000,	// Set to specific values, but not below 1 for toughness.
	ASTERISK_CREATURES_IN_GRAVEYARD_PLUS_POWER_IN_BYTE0_TOUGHNESS_IN_BYTE1_OF_INFO_SLOT	= 0x2000,	// Count creature cards in graveyards, then add values from info_slot.
	ASTERISK_HAND_COUNT						= 0x4000,	// Counts cards in hand.
	ASTERISK_SUBTYPE_OF_INFO_SLOT			= 0x8000,	// Counts permanents with the specified subtype.

	// The oddball.  Both this and ASTERISK_IID_OF_INFO_SLOT must be set.  Counts permanents with the specified card type.
	ASTERISK_TYPE_OF_INFO_SLOT__MUST_ALSO_SET_IID_OF_INFO_SLOT	= 0x100000,
} asterisk_eot_t;

typedef enum
{
	SETTING_AUTO_MILL = 0,
	SETTING_UNLIMITED_MANA,
	SETTING_AUTO_HASTE,
	SETTING_QUICK_START,
	SETTING_CRIPPLE_AI,
	SETTING_CHECK_DECK_LEGALITY,
	SETTING_CHALLENGE_MODE,
	SETTING_SMART_TARGET,
	SETTING_GAMESTART_SETTINGS_APPLIED,
	SETTING_SETTING_FILE_READ,
	SETTING_ALPHABETIZE_DECK,
	SETTING_DUH_MODE,
	SETTING_TOURNAMENT_MODE,
	SETTING_AI_DECISION_TIME,
	SETTING_DEBUG,
	SETTING_RULES_ENGINE,
	SETTING_ATTACH_EQUIPMENT,
	SETTING_AUTOTAP_ARTIFACTS,
	SETTING_AUTOTAP_CREATURES,
	SETTING_VERIFY_HAND_COUNT,
	SETTING_ARCHENEMY,
	SETTING_MIN_PICS_TO_RANDOMIZE,
	SETTING_MANA_BURN,
	SETTING_AI_USES_RULES_ENGINE,
	SETTING_SMALLCARD_SIZE,
	SETTING_HAND_SIZE,

	SETTING_MAX_PLUS_1
} settings_t;

// Constants for play_sound_effect().  Named identically to their filenames in DuelSounds/, except for the duplicate values at the end
typedef enum
{
	WAV_ARTIFACT = 0,	// DuelSounds/artifact.wav
	WAV_BURIED = 1,
	WAV_DRAW = 2,
	WAV_ENCHANT = 3,
	WAV_ENDPHASE = 4,
	WAV_ENDTURN = 5,
	WAV_INSTANT = 6,
	WAV_INTERUPT = 7,

	// Land sounds.
	WAV_GREY = 8,
	WAV_BLACK = 9,
	WAV_BLUE = 10,
	WAV_GREEN = 11,
	WAV_RED = 12,
	WAV_WHITE = 13,

	WAV_LIFELOSS = 14,
	WAV_SACRFICE = 15,
	WAV_SORCERY = 16,
	WAV_SUMMON = 17,
	WAV_TAP = 18,
	WAV_UNTAP = 19,
	WAV_ATTACK2 = 20,
	WAV_BLOCK2 = 21,
	WAV_DAMAGE = 22,
	WAV_DESTROY = 23,
	WAV_DISCARD = 24,
	WAV_KILL = 25,
	WAV_REGEN = 26,

	// Dual-color lands sounds.  Duplicated below in reverse color order.
	WAV_BLACKRED = 27,
	WAV_GREENBLACK = 28,
	WAV_WHITERED = 29,
	WAV_WHITEGREEN = 30,
	WAV_BLACKWHITE = 31,
	WAV_GREENRED = 32,
	WAV_GREENBLUE = 33,
	WAV_WHITEBLUE = 34,
	WAV_BLUEBLACK = 35,
	WAV_REDBLUE = 36,

	WAV_COUNTER = 37,	// "a counter has been added to a card", not "a spell has been countered"
	WAV_FASTFX = 38,
	WAV_CHANGEC = 39,
	WAV_CHANGET = 40,
	WAV_CONTROL = 41,
	WAV_MANABURN = 42,
	WAV_SHUFFLE = 43,
	WAV_SHELL_LOSEDUEL = 44,
	WAV_SHELL_WINDUEL = 45,
	WAV_ASWANJAG = 46,
	WAV_CALLGRAV = 47,
	WAV_FAERDRAG = 48,
	WAV_GEMBAZAR = 49,
	WAV_NECRAZAR = 50,
	WAV_POLKAMIX = 51,
	WAV_PANDORA = 52,
	WAV_PRSMDRAG = 53,
	WAV_PWRSTRGL = 54,
	WAV_CATATAP = 55,
	WAV_ORCART = 56,
	WAV_WHIMSY = 57,
	WAV_RAINBOWK = 58,
	WAV_TOSS = 59,
	WAV_SHELL_SHANDALAR = 60,
	WAV_SHELL_TOOLTIME = 61,
	WAV_SHELL_HELPME = 62,
	WAV_SHELL_HALLOFRECORDS = 63,
	WAV_SHELL_DUELMENOW = 64,
	WAV_EXP1_OPENFOIL = 65,
	WAV_EXP1_OPENBOX = 66,
	WAV_EXP1_OUTOFPACK = 67,
	WAV_EXP1_BACKINPACK = 68,

	// The following duplicate values for convenience, so I don't have to remember it's WAV_BLACKRED instead of WAV_REDBLACK.
	WAV_REDBLACK = WAV_BLACKRED,
	WAV_BLACKGREEN = WAV_GREENBLACK,
	WAV_REDWHITE = WAV_WHITERED,
	WAV_GREENWHITE = WAV_WHITEGREEN,
	WAV_WHITEBLACK = WAV_BLACKWHITE,
	WAV_REDGREEN = WAV_GREENRED,
	WAV_BLUEGREEN = WAV_GREENBLUE,
	WAV_BLUEWHITE = WAV_WHITEBLUE,
	WAV_BLACKBLUE = WAV_BLUEBLACK,
	WAV_BLUERED = WAV_REDBLUE,
	WAV_EXILE = WAV_DESTROY,

	WAV_HIGHEST_EXE = WAV_EXP1_BACKINPACK,

	WAV_BLOODTHIRST = 69,	// A creature with bloodthirst comes into play with counters.
	WAV_DEVOUR = 70,		// A creature activates its devour ability
	WAV_MONSTROSITY = 71,	// A creature activates its monstrosity ability
	WAV_EVOLVE = 72,		// A +1/+1 counter is put on a card because of its evolve ability.
	WAV_PLUS_COUNTER = 73,	// A +x/+x counter is put on a card.
	WAV_MINUS_COUNTER = 74,	// A -x/-x counter is put on a card.
	WAV_MILL = 75,			// Milling effects (as opposed to discard)
	WAV_RAISE_DEAD = 76,	// Card from graveyard to hand
	WAV_BUSHIDO = 77,		// A card gets +x/+x from its bushido ability.
	WAV_EQUIP = 78,			// An equipment card becomes attached to a creature.
	WAV_LIFEGAIN = 79,		// A player gains life.

	// Reuse of unused (or almost-unused) files
	WAV_RESURRECT = WAV_CALLGRAV,		// A card is returned from a graveyard to the battlefield
	WAV_BOUNCE = WAV_SHELL_DUELMENOW,	// A card is returned from the battlefield or stack to its owner's hand.
	WAV_PLANESWALKER = WAV_SHELL_SHANDALAR,	// A planeswalker comes into play

	// No unique sounds yet
	WAV_DETHRONE = WAV_PLUS_COUNTER,	// A +1/+1 counter is put on a card because of its dethrone ability.
	WAV_CREATURE_TOKEN = WAV_SUMMON,	// A creature token put on the battlefield

	WAV_HIGHEST = 79,
} wav_t;

typedef enum
{
  HUMAN =  0,
  AI    =  1,
  ANYBODY = 2,
  TARGET_PLAYER_OWNER = 0x4,	// makes targetting check owner, not controller
  TARGET_PLAYER_OWNER_AND_CONTROLLER = 0xC,	// makes targetting check both owner and controller
} player_t;

/* Targeting system */
typedef struct
{
  int32_t who_chooses;
  int32_t allowed_controller;
  int32_t preferred_controller;
  int32_t zone;
  int32_t required_type;
  int32_t illegal_type;
  int32_t required_abilities;
  int32_t illegal_abilities;
  int32_t required_color;
  int32_t illegal_color;
  int32_t extra;
  int32_t required_subtype;
  int32_t power_requirement;
  int32_t toughness_requirement;
  int32_t special;
  int32_t required_state;
  int32_t illegal_state;
  int32_t allow_cancel;	// 0: no cancel.  1: cancel button.  2: done button.  3: both done and cancel buttons.  If done is chosen, select_target returns 0 and sets target.card to -2.
  int32_t player;
  int32_t card;
} target_definition_t;

typedef enum
{
  TARGET_ZONE_HAND		= 0x100,
  TARGET_ZONE_IN_PLAY	= 0x200,
  TARGET_ZONE_PLAYERS	= 0x1000,
  TARGET_ZONE_CREATURE_OR_PLAYER = TARGET_ZONE_IN_PLAY | TARGET_ZONE_PLAYERS,
  TARGET_ZONE_0x2000	= 0x2000,	// set during blocking selection
  TARGET_ZONE_ON_STACK	= 0x4000,
#ifdef SHANDALAR
  // Values past this can't be combined with others.
  TARGET_ZONE_GRAVEYARD	= 0x01000000,
  TARGET_ZONE_ARRAY		= 0x02000000,	// Target within an arbitrary array.  Set via Target::zone_array(), not directly with Target::zone(TARGET_ZONE_ARRAY).
#endif
} target_zone_t;

typedef enum
{
	TARGET_STATE_TAPPED				= (1 << 0),
	TARGET_STATE_ATTACKING			= (1 << 1),
	TARGET_STATE_ATTACKED			= (1 << 2),	// Checked for but unused by exe
	TARGET_STATE_ISBLOCKED			= (1 << 3),
	TARGET_STATE_BLOCKING			= (1 << 4),
	TARGET_STATE_IN_COMBAT			= (1 << 5),
	TARGET_STATE_ENCHANTED			= (1 << 6),
	TARGET_STATE_JUST_CAST			= (1 << 7),	// Checked for but unused by exe
	TARGET_STATE_SPELL_RESOLVED		= (1 << 8),	// Checked for but unused by exe
	TARGET_STATE_DAMAGED			= (1 << 9),
	TARGET_STATE_COULD_UNTAP		= (1 << 10),	// Target won't necessarily untap during this untap step, but could
	TARGET_STATE_WILL_UNTAP			= (1 << 11),	// Target is going to untap during this untap step.
	TARGET_STATE_SUMMONING_SICK		= (1 << 12),
	TARGET_STATE_TAPPED_OR_BLOCKING	= (1 << 13),	// Not checked for illegal_state
	TARGET_STATE_DESTROYED			= (1 << 14),	// Not checked for illegal_state
	TARGET_STATE_DYING				= TARGET_STATE_DESTROYED,
} target_state_t;

typedef enum
{
  TARGET_PT_MASK				= 0x0FFF,	// Legal numeric values
  TARGET_PT_GREATER_OR_EQUAL	= 0x1000,
  TARGET_PT_LESSER_OR_EQUAL		= 0x2000,
  TARGET_PT_INCLUDE_DAMAGE		= 0x4000,	// Creature's effective toughness for purpose of targeting is reduced by damage already assigned.  Only makes sense for ai-specific code.
} target_pt_t;

typedef enum
{
	// Some of these aren't used in Shandalar.dll, and have been verified not to be used from Shandalar.exe; they're removed, and some repurposed as well.

	TARGET_SPECIAL_WALL					= (1 << 0),
	TARGET_SPECIAL_SPELL_ON_STACK		= (1 << 1),
	TARGET_SPECIAL_BASIC_LAND			= (1 << 2), // Optional land color - 1 in extra.  Checked for but unused by exe.
#ifndef SHANDALAR
	TARGET_SPECIAL_ARTIFACT_CREATURE	= (1 << 3),	// Checked for but unused by exe
#endif
	TARGET_SPECIAL_0x10					= (1 << 4),	// Used in calls from Aswan Jaguar but not checked
	TARGET_SPECIAL_DAMAGE_PLAYER		= (1 << 5), // Referring to the 'player' who controls the card with the targeting function.
	TARGET_SPECIAL_DJINN_OR_EFREET		= (1 << 6), // Used only by King Suleiman
	TARGET_SPECIAL_NON_WALL				= (1 << 7),
#ifndef SHANDALAR
	TARGET_SPECIAL_NOT_LAND_SUBTYPE		= (1 << 8),	// Land color - 1 in extra - e.g. swamp is COLOR_BLACK-1==0, plains is COLOR_WHITE-1==4.	(Note that using extra from 0 to 4 and special==0 is the opposite of this.)
#endif
	TARGET_SPECIAL_USE_ORIGINAL_TYPE	= (1 << 9),	// Used by exe for Clone/Vesuvan Doppelganger/Copy Artifact; disabled in C version
	TARGET_SPECIAL_ALLOW_MULTIBLOCKER	= (1 << 10),	// Lets a multiblocker shadow be chosen
	TARGET_SPECIAL_CMC_LESSER_OR_EQUAL	= (1 << 11),	// Target's cmc must be <= extra (which must be >= 0).  Extension to exe.
	TARGET_SPECIAL_ILLEGAL_SUBTYPE		= (1 << 12),	// required_subtype field is considered illegal_subtype.  Extension to exe.
	TARGET_SPECIAL_ELEPHANT_MAMMOTH		= (1 << 13),	// Used only by Elephant Graveyard

	// The rest are all extensions to exe.
	TARGET_SPECIAL_NOT_ME				= (1 << 14),	// (td->player, td->card) is an illegal target.  Unimplemented if real_target_available()/real_select_target()/real_validate_target() are called directly without a target_definition_t.
#ifndef SHANDALAR
	TARGET_SPECIAL_EXTRA_FUNCTION		= (1 << 15),	// Calls extra, which is a pointer to function with signature const char* function(int who_chooses, int player, int card, int targeting_player, int targeting_card).  (It can take fewer arguments if it doesn't need them.)  It should return NULL if a legal target, or an error message if illegal.
#endif
	TARGET_SPECIAL_EXTRA_NOT_IID		= (1 << 16),	// Usually, if extra is >= 5 and none of TARGET_SPECIAL_EXTRA_FUNCTION, TARGET_SPECIAL_CMC_LESSER_OR_EQUAL, TARGET_SPECIAL_NOT_LAND_SUBTYPE, or TARGET_SPECIAL_BASIC_LAND is set, only targets with iids matching extra are legal.  This makes it so only targets not matching extra are.
	TARGET_SPECIAL_EFFECT_CARD			= (1 << 17),	// The targeted card must be an effect card; other tests of required_type/illegal_type are against its source.
	TARGET_SPECIAL_REQUIRES_COUNTER		= (1 << 18),	// BYTE0(extra) is the counter type; BYTE1(extra) is the number needed (defaults to 1 if unset).
#ifndef SHANDALAR
	// Wasteful.  Should either use one bit like TARGET_SPECIAL_EFFECT_CARD, or set it in zone.
	TARGET_SPECIAL_DAMAGE_ANY_PLAYER	= (1 << 19),
	TARGET_SPECIAL_DAMAGE_CREATURE		= (1 << 20),
	TARGET_SPECIAL_DAMAGE_LEGENDARY_CREATURE		= (1 << 21),
	TARGET_SPECIAL_DAMAGE_PERMANENT_WITH_SUBTYPE	= (1 << 22), //will look at the 'required_subtype' argument
	TARGET_SPECIAL_REGENERATION			= (1 << 23), //checks both the "kill_code" for "KIL_DESTROY" and "token_status" for "STATUS_CANNOT_REGENERATE"
#endif
	TARGET_SPECIAL_CMC_GREATER_OR_EQUAL	= (1 << 24),

#ifdef SHANDALAR
	TARGET_SPECIAL_REQUIRE_ALL_TYPES	= (1 << 3),		// all types in required_types must match, instead of any - e.g., normally "required_type = TYPE_CREATURE|TYPE_ENCHANTMENT" means "creature or enchantment", but with this, it means "enchantment creature".
	TARGET_SPECIAL_OR_ME				= (1 << 8),		// source of targetting can always be picked if it's in the right zone, ignoring all other requirements
	TARGET_SPECIAL_EXTRA_OR_SUBTYPE		= (1 << 15),	// extra works as another subtype field; matching either subtype or extra is sufficient to pass.
#endif
} target_special_t;

typedef enum
{
	DISC_RANDOM = 1<<0,
	DISC_CAUSED = 1<<1,
} discard_flags_t;

typedef struct
{
	target_t from, to;
} HackForceEffectChangeSource;

typedef enum
{
	CECT_HUMAN_CAN_CANCEL	= 1<<0,	// Human can choose to cancel.
	CECT_AI_CAN_CANCEL		= 1<<1,	// AI can choose to cancel.  Implies CECT_HUMAN_CAN_CANCEL.  Doesn't set cancel=1 if the cancel option is chosen.
	CECT_AI_NO_DIALOG		= 1<<2,	// Passes DLG_NO_DISPLAY_FOR_AI to the dialog.
	CECT_AUTOCHOOSE_BEST	= 1<<3,	// Automatically chooses the best-rated counter type, even for a human player, and doesn't display a dialog.
	CECT_CONSIDER_ALL		= 1<<4,	// AI considers adding even detrimental counters, or removing even beneficial ones.

	// Only one of CECT_REMOVE, CECT_ADD_OR_REMOVE, or CECT_MOVE shuld be set.  If none are, it's assumed to be adding counters.
	CECT_REMOVE				= 1<<5,	// Picks AI (and CECT_AUTOCHOOSE_BEST) priorities as if the chosen counter type is to be removed, not added.
	CECT_ADD_OR_REMOVE		= 1<<6,	// Picks priorities based on the greater of the add and remove scores.  Sets bit 1<<9 in return value if the chosen counter type should be removed.
	CECT_MOVE				= 1<<7,	// Picks priorities based on removing from {t_player,t_card} and adding to {smallcard_player, smallcard_card}, which must be given.
	//CECT_ADD				= 1<<8,	// For internal use in choose_existing_counter_type.  Don't use directly; but don't set a value here, either.
} cect_t;

typedef enum {
	PAUE_ENABLE_NONMANA_ACTIVATED_ABILITIES_AT_EOT	= 1<<0,
	PAUE_ENABLE_ALL_ACTIVATED_ABILITIES_AT_EOT		= 1<<1,
	PAUE_DE_HUMILIATE_AT_EOT						= 1<<2,
	PAUE_RESET_SUBTYPES_AT_EOT						= 1<<3,
	PAUE_CANT_ATTACK								= 1<<4,
	PAUE_KILL_SOURCE_IF_LEAVES_BATTLEFIELD			= 1<<5,	// if damage_target_player/card leaves the battlefield, then kill damage_source_player/card with kill code in targets[3].card
	PAUE_END_AT_END_OF_COMBAT						= 1<<6,	// Remove effect at end of combat (in addition to at end of turn)
	PAUE_END_IF_SOURCE_UNTAP						= 1<<7,
	PAUE_END_IF_SOURCE_LEAVES_PLAY					= 1<<8,
	PAUE_END_AT_EOT									= 1<<9,
	PAUE_SPIRIT_LINK_PLAYER0						= 1<<10,
	PAUE_SPIRIT_LINK_PLAYER1						= 1<<11,
	PAUE_SPIRIT_LINK_TARGET_CONTROLLER				= 1<<12,
	PAUE_REMOVE_ABILITIES							= 1<<13,
	PAUE_REMOVE_TARGET_AT_EOT						= 1<<14, // Uses "eot_removal_method"
	PAUE_END_AT_THE_BEGINNING_OF_YOUR_NEXT_TURN		= 1<<15,
	PAUE_UNTAP										= 1<<16,
} paue_3player_t;

typedef struct pump_ability_until_eot_arguments_t
{
	int source_p;
	int source_c;
	int pow_mod;
	int tou_mod;
	int key_mod;
	int skey_mod;
	int paue_flags;
	int can_block_additional_creatures;
	int eot_removal_method;
} pump_ability_t;

typedef enum {
	// seek_grave_for_id_to_reanimate compares >= 0

	// Lots of these aren't meaningfully combineable.
	REANIMATE_DEFAULT					= 0,
	REANIMATE_TAP						= (1<<0),	// Tap the reanimated permanent
	REANIMATE_NO_CONTROL_LEGACY			= (1<<1),	// Don't create a visible legacy if the permanent isn't owned by its new controller
	REANIMATE_UNEARTH					= (1<<2),	// Exile the reanimated permanent at end of turn of if it would leave play
	REANIMATE_ADD_BLACK_ZOMBIE			= (1<<3),	// Add color black and subtype Zombie to the reanimated permanent
	REANIMATE_HASTE_AND_EXILE_AT_EOT	= (1<<4),	// Give the reanimated permanent haste and exile it at end of turn
	REANIMATE_PLUS1_PLUS1_COUNTER		= (1<<5),	// Give the reanimated permanent a +1/+1 counter
	REANIMATE_MINUS1_MINUS1_COUNTER		= (1<<6),	// Give the reanimated permanent a -1/-1 counter
	REANIMATE_HASTE_UNTIL_EOT			= (1<<7),	// Give the reanimated permanent haste until end of turn
	REANIMATE_ATTACH_AS_AURA			= (1<<8),	// Attach (player/card) to the animated card instead of creating an effect card
	REANIMATE_RETURN_TO_HAND			= (1<<9),	// Problematic.  Still tests for Grafdigger's Cage, etc., with the idea that the calling function will put the card onto the battlefield; but that's only true for a couple cases.  Not meaningfully combineable with any other mode.
	REANIMATE_ALL_UNDER_CASTERS_CONTROL	= (1<<10),	// For reanimate_all(), all creatures come under control of player, not the player whose graveyard they're from.
	REANIMATE_UNDER_OWNER_CONTROL		= (1<<11),	// For special cases like Gift of Immortality
	REANIMATE_SPECIAL_R_ALL				= (1<<12),	// Used only internally by reanimate all: tells 'reanimate_permanent' that the card to put in play is actually on targ_player hand. Prevents messy effects when stuff like Gravedigger is reanimated.
	REANIMATE_HASTE_AND_EXILE_AT_YOUR_UPKEEP	= (1<<13),
	// These two valid only for seek_grave_for_id_to_reanimate.  Can't be combined with any of the modes above.
	REANIMATEXTRA_RETURN_TO_HAND2 = -1,	// Doesn't have the problems REANIMATE_RETURN_TO_HAND does, though only valid in seek_grave_for_id_to_reanimate
	REANIMATEXTRA_LEAVE_IN_GRAVEYARD = -2,
} reanimate_mode_t;

typedef enum
{
	SHAPESHIFT_UNTIL_EOT			= 0x01,	// Effect ends at end of turn; otherwise permanent, unless SHAPESHIFT_COUNTER_FLAG is set.
	SHAPESHIFT_EFFECT_WHEN_REMOVE	= 0x02,	// When this effect removes itself (via SHAPESHIFT_UNTIL_EOT or SHAPESHIFT_COUNTER), add an activateable legacy effect to the permanent, with function stored in targets[2].player.  (The latter must be set manually; if left unset, this has no effect.)
#define SHAPESHIFT_COUNTER(counter_type)	(SHAPESHIFT_IMPL_COUNTER_FLAG | ((counter_type & 0xFF) << 24))	// Effect ends if permanent doesn't have a counter of type counter_type on it.

	// The following bits are reserved for the implementation; don't set directly.
	SHAPESHIFT_IMPL_COPYING_TOKEN	= 0x00400000,	// Turned into a token with characteristic-setting effects.
	SHAPESHIFT_IMPL_COUNTER_FLAG	= 0x00800000,	// Effect ends if permanent doesn't have an appropriate counter on it.  Shouldn't be set directly; use the SHAPESHIFT_COUNTER() macro.
	SHAPESHIFT_IMPL_COUNTER_MASK	= 0xFF000000,	// Storage for counter_type
} shapeshift_t;

typedef enum {
	PREVENT_ADD_1_1_COUNTER = (1<<0),	// add a +1+1 counter for each 1 damage prevented
	PREVENT_GAIN_LIFE = (1<<1),			// gain life equal to the damage prevented
	PREVENT_REDIRECT = (1<<2),			// deal damage to redir_to_player/redir_to_card equal to the damage prevented
	PREVENT_INFINITE = (1<<3),			// no limit to damage prevented
} prevent_t;

typedef enum {
	IPF_TARGET = 1,
	IPF_ATTACH_AURA,
	IPF_ATTACH_EQUIPMENT,	// or fortification
	IPF_DAMAGE,
	IPF_BLOCK,
} is_protected_from_mode_t;

typedef enum
{
	FOG_COLORLESS_CREATURES_ONLY	= 1<<0,
	FOG_BLACK_CREATURES_ONLY		= 1<<1,
	FOG_BLUE_CREATURES_ONLY			= 1<<2,
	FOG_GREEN_CREATURES_ONLY		= 1<<3,
	FOG_RED_CREATURES_ONLY			= 1<<4,
	FOG_WHITE_CREATURES_ONLY		= 1<<5,
	FOG_COLOR_MASK					= FOG_COLORLESS_CREATURES_ONLY | FOG_BLACK_CREATURES_ONLY | FOG_BLUE_CREATURES_ONLY | FOG_GREEN_CREATURES_ONLY | FOG_RED_CREATURES_ONLY | FOG_WHITE_CREATURES_ONLY,
	FOG_INVERSE_COLOR_CHECK			= 1<<7, // AKA "Prevent all damage done by creatures that aren't of the color specified by FOG flags"
	FOG_COMBAT_DAMAGE_ONLY			= 1<<8,
	FOG_UNBLOCKED_CREATURES_ONLY	= 1<<9,
	FOG_CREATURES_WITHOUT_TRAMPLE	= 1<<10,
} fog_special_flags_t;

typedef enum {
	CHANGE_COLOR_ADD		= 1 << 0,
	CHANGE_COLOR_SET		= 1 << 1,
	CHANGE_COLOR_END_AT_EOT	= 1 << 2,
	CHANGE_COLOR_NO_SOUND	= 1 << 3,	// Don't play WAV_CHANGEC (e.g., this is being added to the affected card as it's being created)
	CHANGE_COLOR_NO_SLEIGHT	= 1 << 4,	// Don't apply player/card's sleight status
} change_color_t;

typedef enum {
	GA_FORBID_NONMANA_ACTIVATED_ABILITIES	= 1<<0,
	GA_FORBID_HUMILIATE						= 1<<1,
	GA_FORBID_ALL_ACTIVATED_ABILITIES		= 1<<2,
	GA_ADD_SUBTYPE							= 1<<3,
	GA_FORCE_SUBTYPE						= 1<<4,
	GA_FORCE_COLOR							= 1<<5,
} generic_aura_flags_t;

typedef enum {
	EATM_CHECK			= 0,
	EATM_REPORT_TOTAL	= 1<<0,
	EATM_UNATTACH		= 1<<1,
	EATM_DESTROY		= 1<<2,
} equipments_attached_to_me_mode_t;

typedef enum {
	RIFG_REMOVE_ALL = (1<<0),
	RIFG_OBLITERATE = (1<<1),
} remove_id_from_grave_t;

typedef enum
{
	FC_HEAD		= 0,
	FC_TAILS	= 1
} flip_a_coin_values;

typedef enum
{
	/* These values are chosen to all fall within KEYWORD_RECALC_ALL's bits: 1<<24 ... 1<<28 (i.e. 1<<24 to 31<<24)
	 * Pass them in the keyword parameter to either vanilla_pump or vanilla_instant_pump.
	 * They can be combined with normal keywords, but not each other.
	 * Since there's only 31 values available, prefer VANILLA_PUMP_DONT_KILL_CARD to adding a new effect unless you expect to use it many cards.  See
	 * battle_for_zendikar.c:card_swell_of_growth() for an example. */
	VANILLA_PUMP_DRAW_A_CARD = 1<<24,
	VANILLA_PUMP_SCRY_1 = 2<<24,
	VANILLA_PUMP_CANTRIP = 3<<24,	// Normal pumping effect text should be in |#1, cantrip effect in |#2
	VANILLA_PUMP_DONT_KILL_CARD = 4<<24,	// If the target validates during EVENT_RESOLVE_SPELL, instead wrap the legacy in alternate_text |#1 and return 1 instead of putting this card in the graveyard, which becomes the caller's responsibility.  (If the target doesn't validate, puts the card in the graveyard and returns 0.)
	VANILLA_PUMP_REGENERATE = 5<<25,	// Regenerate the targeted creature (or create a regeneration shield) in addition to other effects.  |#1 should be the other effects, |#2 the regeneration shield.
	VANILLA_PUMP_REGENERATE_DONT_KILL_CARD = 6<<26,	// Effects of both VANILLA_PUMP_REGENERATE and VANILLA_PUMP_DONT_KILL_CARD.
} vanilla_pump_side_effects;

typedef enum {
	// Bits 0..3 reserved to mirror resolve_trigger_t.  If none are set, then defaults to RESOLVE_TRIGGER_MANDATORY as a convenience.
	DAT_ATTACKS_PLAYER		= (1<<4),	// only triggers if attacking a player, not a planeswalker
	DAT_ATTACKS_PLANESWALKER= (1<<5),	// only triggers if attacking a planewalker, not a player

	DAT_TRACK				= (1<<6),	// Store the first 64 attackers starting at (player,card)->targets[2].player, one unsigned char per attacker.  Will overwrite targets[2] to targets[9].
	DAT_SEPARATE_TRIGGERS	= (1<<7),	// Each time it triggers can be activated separately.  Only meaningful for the human player and only if trigger mode isn't mandatory.  Not exactly incompatible with DAT_TRACK, but it's probably a bad idea.

	DAT_ATTACKS_ALONE		= (1<<8),	// only triggers if exactly one attacker was declared
	DAT_ATTACKS_WITH_3_OR_MORE = (1<<9),// only triggers if three or more attackers were declared.  (The count could be gotten from the return value, yes, but only after it had triggered.)

	DAT_STORE_IN_TARGETS_3	= (1<<10),	// Store internal data in targets[3].player instead of targets[1].player, since there aren't really any slots guaranteed free even amongst just the cards that call this.
	DAT_STORE_IN_INFO_SLOT	= (1<<11),	// Store internal data in info_slot instead of targets[1].player, since there aren't really any slots guaranteed free even amongst just the cards that call this.
} declare_attackers_trigger_t;

typedef enum
{
	SAC_NO_CANCEL			= 1<<0,	// Don't show a cancel button.  Needs to stay at 1.
	SAC_DONE				= 1<<1,	// Show a done button.  Needs to stay at 2.
	SAC_JUST_MARK			= 1<<2,	// Don't actually sacrifice the chosen permanent or permanents, just set STATE_CANNOT_TARGET.  Will also be available in marked_for_sacrificed[] if called via mark_sacrifice().
	SAC_ALL_OR_NONE			= 1<<3,	// Unless all targets are chosen, don't sacrifice any of them.
	SAC_AS_COST				= 1<<4,	// Disallow sacrifice of creatures if there's an Angel of Jubilation in play.
	SAC_CAUSED				= 1<<5,	// Disallow all sacrifices if player != t_player and t_player controls Tajuru Preserver or Sigarda, Host of Herons.
	SAC_RETURN_CHOICE		= 1<<6,	// Returns the sacrificed {player,card} in {BYTE2,BYTE3} of the return value.  If sacrificing more than one, then only returns the last.
	SAC_SET_TARGETS			= 1<<7,	// Sets a bunch of values in {player,card}'s targets[0] - targets[4], for backwards compatibility with the old sacrifice() interface.  Avoid.
} sacrifice_t;

typedef enum
{
	SARV_REPORT_POWER		= 1<<0,		// Use only one of these or you'll get messed result
	SARV_REPORT_TOUGHNESS	= 1<<1,		// Use only one of these or you'll get messed result
	SARV_REPORT_COLORS		= 1<<2,		// Use only one of these or you'll get messed result
	SARV_REPORT_CMC			= 1<<4,		// Use only one of these or you'll get messed result
	SARV_EXTRA_IMPOSE_SACRIFICE	= 1<<31 // Can be mixed with the other parameters
} sacrifice_and_report_value_flags_t;

typedef enum
{
	SFG_CANNOT_CANCEL		= 1,
	SFG_NOTARGET			= 2,	// unaffected by graveyard_has_shroud
	SFG_NO_SPELL_FIZZLED	= 4,	// Does not set "cancel" to "1" if no target is selected, see "Pull from the Deep"
} select_grave_t;

typedef enum {
	DISCARD_NO_NORMAL		= 1<<0,	// don't trigger during discard/cleanup phases
	DISCARD_STILL_IN_HAND	= 1<<1,	// don't trigger unless card being discarded is still in hand (and so hasn't already been moved elsewhere)
} discard_trigger_t;

typedef enum {
	GFPC_STORE_POWER			= 1<<0,	//Only of this parameters shoudl be used at once
	GFPC_STORE_TOUGHNESS		= 1<<1,	//Only of this parameters shoudl be used at once
	GFPC_STORE_CMC				= 1<<2,	//Only of this parameters shoudl be used at once
	GFPC_STORE_COLORS			= 1<<3,	//Only of this parameters shoudl be used at once
	GFPC_TRACK_DEAD_CREATURES	= 1<<4,	////Only of this parameters shoudl be used at once. Will store the "internal_card_id" of the dead creatures from "targets[storage_locatio].player" to a maximum of "targets[9].player"
	GFPC_EXTRA_SKIP_TOKENS		= 1<<5, //Can be combined with the previous values.
} count_for_gfp_ability_and_store_values_flags_t;

typedef enum {
	GCUS_CONTROLLED = 1,	// lose control if lose control of source
	GCUS_TAPPED = 2,		// lose control if source isn't tapped
	GCUS_BURY_IF_TAPPED_OR_LEAVE_PLAY = 4,	// bury controlled permanent if source leaves play or becomes untapped (but not if controlled)
} gcus_t;

typedef enum {
	// Commands. Exactly one should be set.
	EXBY_CHOOSE			= 0,	// Choose a card, and return an int* (cast to an int) to a value encoding the internal_card_id as (*rval & ~0x80000000) and owner as (*rval & 0x80000000).  Returns NULL if cancelled or no cards match the given test.  Can then unremember the card by setting *rval = -1.
	EXBY_MAX_VALUE		= 1,	// Returns the value of the highest value card (by my_base_value_by_id) matching the given test, or INT_MIN if none match.  (Number chosen to match AI_MAX_VALUE.)
	EXBY_CAN_CAST		= 2,	// Returns 99 if any card matching tests can be cast and its EVENT_CAN_CAST handler returns 99; or 1 if any card matching tests can be cast; or 0.  Should also set EXBY_TEST_CAN_CAST.
	EXBY_FIRST_FOUND	= 5,	// Returns an int* (as for EXBY_CHOOSE) to the first card found matching the given tests.  (Number chosen to match AI_FIRST_FOUND.)

	EXBY_MODE_MASK		= (1<<16)-1,

	// Tests.  Only mutually compatible if their testarg specifications don't conflict.
	EXBY_TEST_CMC_LE	= 1<<16,	// Only cards with cmc <= testarg are legal choices.  If exactly match cmc, then halve value in EXBY_HIGHEST_VALUE and for AI in EXBY_CHOOSE.
	EXBY_TEST_IID		= 1<<17,	// Only cards with iid == testarg, or the same csvid as iid's, are legal choices.
	EXBY_TEST_CAN_CAST	= 1<<18,	// Only cards that player could cast.  testarg is the current event.
	EXBY_TEST_HAS_MANA_TO_CAST	= 1<<19,	// Only cards that player has the mana to cast.  testarg is the current event.
} exiledby_choose_mode_t;

typedef enum {
	TYPETEXT_NO_ABBREV = 1<<0,	/* Don't abbreviate "instant interrupt" to "instant", "artifact creature enchantment land" or "artifact creature enchantment
								 * land planeswalker" to "permanent", or "permanent instant sorcery" to "card". */
	TYPETEXT_INVERT = 1<<1,		// Precede each returned type with "non", and put a comma between the last two types instead of "or".
#ifdef SHANDALAR
	TYPETEXT_A		= 1<<2,
#endif
} type_text_t;

typedef enum {
	FBL_NO_MANA_COST = 1 << 0,
} flashback_legacy_t;

typedef enum
{
  MPCFE_FOR_FREE	= 1<<0,	// no mana cost
  MPCFE_FOR_CMC		= 1<<1,	// may spend mana as thought it were mana of any color to cast that spell
  MPCFE_FACE_DOWN	= 1<<2,	// card was exiled face-down; player may look at it.
  MPCFE_UNTIL_EOT	= 1<<3,	// can only play until end of turn
  MPCFE_ATTACH		= 1<<4,	// attach effect to {player,card}, so can only play so long as its source is on the battlefield
  MPCFE_UNTIL_END_OF_YOUR_NEXT_TURN = 1<<5,	// can only play until the end of your next turn
} mpcfe_mode_t;

typedef enum
{
  EPAAC_STORE_AURAS_RETURN_EOT						= 1<<0,	// store exiled auras on a separate legacy, as they will be returned in play at eot
  EPAAC_STORE_COUNTERS_RETURN_EOT					= 1<<1,	// store counters from exiled permanent on a separate legacy, as they will be returned in play at eot
  EPAAC_STORE_AURAS_RETURN_IF_SOURCE_LEAVES_PLAY	= 1<<2,	// store exiled auras on a separate legacy, as they will be returned in play at eot
  EPAAC_STORE_COUNTERS_RETURN_IF_SOURCE_LEAVES_PLAY	= 1<<3,	// store counters from exiled permanent on a separate legacy, as they will be returned in play at eot
  EPAAC_RETURN_TO_PLAY_TAPPED						= 1<<4,	// the exiled permanent will return into play tapped
  EPAAC_TAWNOSS_COFFIN								= 1<<5,	// store auras + counters, return them if source leaves play or untap
} exile_permanent_and_auras_attached_mode_t;

typedef enum
{
  NSLA_EXILE_FROM_PLAYERS_DECK				= 1<<0,
  NSLA_EXILE_FROM_DAMAGED_PLAYER_DECK		= 1<<1,
  NSLA_REMOVE_STORED_CARDS_AT_EOT			= 1<<2,
  NSLA_MUST_PAY_MANACOST_OF_EXILED_CARDS	= 1<<3,
  NSLA_EXILE_ONLY_WITH_COMBAT_DAMAGE		= 1<<4,
  NSLA_EXILE_ONLY_WHEN_DAMAGING_PLAYER		= 1<<5,
} nightveil_specter_like_ability_flags_t;

typedef enum
{
	AUTOTAP_NO_BASIC_LANDS		= 1<<0,
	AUTOTAP_NO_NONBASIC_LANDS	= 1<<1,
	AUTOTAP_NO_DONT_AUTO_TAP	= 1<<2,
	AUTOTAP_NO_ARTIFACTS		= 1<<3,
	AUTOTAP_NO_CREATURES		= 1<<4
} autotap_t;

/* Repeatedly do something until it's not cancelled.  Dangerous; use only for things you know the AI won't cancel (even while speculating), and that the human
 * player is able to do without cancelling; and that doesn't have any side effects if cancelled.  Mana production choices or choosing a number are ok, for
 * example; charging mana is not. */
#define FORCE(cmds) do { cancel = 0; cmds; } while (cancel == 1)

/* Do something for the active player, then the same thing for the non-active player.  See Pox for an example.  Anything passed to this macro will be evaluated
 * at least twice, obviously. */
#define APNAP(playervar, ...)	do { int playervar = current_turn; {__VA_ARGS__;} playervar = 1-current_turn; {__VA_ARGS__;} } while (0)

#define COMPARE(a, comparator, b)		\
({										\
  __typeof__(a) macro_compare_a = (a);	\
  __typeof__(b) macro_compare_b = (b);	\
  macro_compare_a comparator macro_compare_b ? macro_compare_a : macro_compare_b;	\
})
#define MIN(a, b) COMPARE(a, <, b)
#define MAX(a, b) COMPARE(a, >, b)

#define CLAMP(val, lo, hi)					\
({											\
  __typeof__(val) macro_clamp_val = (val);	\
  __typeof__(lo) macro_clamp_lo = (lo);		\
  __typeof__(hi) macro_clamp_hi = (hi);		\
  macro_clamp_val < macro_clamp_lo			\
	  ? macro_clamp_lo						\
	  : (macro_clamp_val > macro_clamp_hi	\
		 ? macro_clamp_hi					\
		 : macro_clamp_val);				\
})

#define SWAP(a, b)	do { __typeof__(a) temp_swap_ = a; a = b; b = temp_swap_; } while (0)	// gcc extension: typeof
#define SGN(v)		(((v) > 0) - ((v) < 0))		// -1 if v is less than 0; +1 if v is greater than 0; 0 if v is equal to 0.  From http://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign
#define STRINGIZE_IMPL(x) #x
#define STRINGIZE(x) STRINGIZE_IMPL(x)

// Uses gcc statement expression extension.
#define EXE_FN(returntyp, loc, ...)			\
({											\
  typedef returntyp (*FnTyp)(__VA_ARGS__);	\
  (FnTyp)(loc);								\
})

#define EXE_STDCALL_FN(returntyp, loc, ...)				\
({														\
  typedef returntyp (__stdcall *FnTyp)(__VA_ARGS__);	\
  (FnTyp)(loc);											\
})

#define EXE_PTR_VOID(addr)	(*(void**)(addr))

#define EXE_DWORD_PTR(addr)	((int*)(addr))
#define EXE_DWORD(addr)		(*EXE_DWORD_PTR(addr))

#define EXE_WORD_PTR(addr)	((short int*)(addr))
#define EXE_WORD(addr)		(*EXE_WORD_PTR(addr))

#define EXE_BYTE_PTR(addr)	((char*)(addr))
#define EXE_BYTE(addr)		(*EXE_BYTE_PTR(addr))

#define EXE_STR(addr)	((const char*)(addr))

#ifdef LOWORD
#  undef LOWORD
#endif
#ifdef HIWORD
#  undef HIWORD
#endif
#define LOWORD(l)		((uint16_t)((l) & 0xFFFF))
#define SET_LOWORD(l)	(*(uint16_t*)(&(l)))
#define HIWORD(l)		((uint16_t)(((l) >> 16) & 0xFFFF))
#define SET_HIWORD(l)	(*((uint16_t*)(&(l)) + 1))
#define BYTE0(l)		((uint8_t)((l) & 0xFF))
#define SET_BYTE0(l)	(*(uint8_t*)(&(l)))
#define BYTE1(l)		((uint8_t)(((l) >> 8) & 0xFF))
#define SET_BYTE1(l)	(*((uint8_t*)(&(l)) + 1))
#define BYTE2(l)		((uint8_t)(((l) >> 16) & 0xFF))
#define SET_BYTE2(l)	(*((uint8_t*)(&(l)) + 2))
#define BYTE3(l)		((uint8_t)(((l) >> 24) & 0xFF))
#define SET_BYTE3(l)	(*((uint8_t*)(&(l)) + 3))

#define SLOWORD(l)		((int16_t)((l) & 0xFFFF))
#define SET_SLOWORD(l)	(*(int16_t*)(&(l)))
#define SHIWORD(l)		((int16_t)(((l) >> 16) & 0xFFFF))
#define SET_SHIWORD(l)	(*((int16_t*)(&(l)) + 1))
#define SBYTE0(l)		((int8_t)((l) & 0xFF))
#define SET_SBYTE0(l)	(*(int8_t*)(&(l)))
#define SBYTE1(l)		((int8_t)(((l) >> 8) & 0xFF))
#define SET_SBYTE1(l)	(*((int8_t*)(&(l)) + 1))
#define SBYTE2(l)		((int8_t)(((l) >> 16) & 0xFF))
#define SET_SBYTE2(l)	(*((int8_t*)(&(l)) + 2))
#define SBYTE3(l)		((int8_t)(((l) >> 24) & 0xFF))
#define SET_SBYTE3(l)	(*((int8_t*)(&(l)) + 3))

#endif
